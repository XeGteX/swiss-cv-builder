This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: node_modules, .git, dist, dist-server, coverage, *.log, package-lock.json, yarn.lock, pnpm-lock.yaml, .env, **/*.spec.ts, **/*.test.ts, test-output.pdf, repomix-output.xml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
adapters/index.ts
adapters/mapAppToNexal2.ts
components/index.ts
components/NEXAL2PreviewPane.tsx
components/StructurePanel.tsx
constraints/createConstraints.ts
constraints/index.ts
constraints/presets.ts
constraints/regions.ts
dev/GoldenProfiles.ts
dev/index.ts
dev/LayoutValidator.ts
dev/LongProfileRunner.ts
dev/MatrixRunner.ts
dev/PaginationCIGate.ts
dev/PaginationMatrixRunner.ts
editing/applyFieldPatch.ts
editing/index.ts
editing/InlineEditOverlay.tsx
hooks/index.ts
hooks/useNexal2.ts
index.ts
layout/computeLayout.ts
layout/index.ts
layout/paginateLayout.ts
renderers/html/EditableHTMLRenderer.tsx
renderers/html/HTMLRenderer.tsx
renderers/html/index.ts
renderers/pdf/index.ts
renderers/pdf/PDFRenderer.tsx
scenegraph/buildScene.ts
scenegraph/index.ts
test/fixtures.ts
test/index.ts
test/Nexal2TestPage.tsx
types.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="adapters/index.ts">
/**
 * NEXAL2 Adapters Index
 */

export { mapAppToNexal2, mapProfileToNexal2, mapDesignToNexal2 } from './mapAppToNexal2';
</file>

<file path="adapters/mapAppToNexal2.ts">
/**
 * NEXAL2 - App Profile/Design Adapter
 *
 * Maps the application's CVProfile and DesignConfig to NEXAL2-compatible format.
 * NEXAL2 remains the source of truth (SceneGraph â†’ LayoutTree â†’ Renderers).
 *
 * Data sources:
 * - CVProfile: from useProfile() hook
 * - DesignConfig: from useDesign() hook (separate store state)
 *
 * Sprint 6.2: Fixed education mapping with robust key aliasing.
 */

import type { CVProfile } from '@/domain/cv/v2/types';
import type { DesignConfig } from '@/application/store/v2/cv-store-v2.types';

// ============================================================================
// STRING HELPER
// ============================================================================

/** Safe string coercion: null/undefined â†’ '', otherwise trim */
const s = (v: unknown): string => (v == null ? '' : String(v).trim());

// ============================================================================
// NEXAL2 PROFILE TYPE (what buildScene expects)
// ============================================================================

/**
 * NEXAL2 Profile - Normalized structure for buildScene.
 *
 * IMPORTANT: This must match what buildScene.ts expects:
 * - personal.contact.email/phone/address (nested)
 * - educations (plural, not education)
 * - experiences (plural)
 */
export interface Nexal2Profile {
    id?: string;
    personal?: {
        firstName?: string;
        lastName?: string;
        title?: string;
        photoUrl?: string;
        contact?: {
            email?: string;
            phone?: string;
            address?: string;
        };
    };
    summary?: string;
    skills?: string[];
    languages?: Array<{ name: string; level: string }>;
    experiences?: Array<{
        company?: string;
        role?: string;  // buildScene uses 'role'
        dates?: string;
        dateRange?: { displayString?: string; isCurrent?: boolean };
        tasks?: string[];
    }>;
    educations?: Array<{  // Plural to match buildScene
        degree?: string;
        school?: string;
        year?: string;
    }>;
}

/**
 * NEXAL2 Design Config (what buildScene expects)
 */
export interface Nexal2Design {
    paperFormat: 'A4' | 'LETTER';
    accentColor: string;
    fontPair: string;
    showPhoto: boolean;
    sidebarPosition: 'left' | 'right';
    headerStyle: 'classic' | 'modern' | 'minimal';
}

// ============================================================================
// PROFILE ADAPTER
// ============================================================================

/**
 * Map app CVProfile to NEXAL2 profile format.
 *
 * Sprint 6.2: Robust key aliasing for education fields.
 *
 * @param profile - App CVProfile from store
 * @returns Nexal2Profile with normalized structure
 */
export function mapProfileToNexal2(profile: CVProfile | undefined): Nexal2Profile {
    if (!profile) {
        return {
            id: '',
            personal: {
                firstName: '',
                lastName: '',
                title: '',
                contact: { email: '', phone: '', address: '' },
            },
            summary: '',
            skills: [],
            languages: [],
            experiences: [],
            educations: [],
        };
    }

    // Normalize experiences - ensure dates field is populated
    const normalizedExperiences = (profile.experiences || []).map((exp) => ({
        company: s(exp.company),
        role: s(exp.role) || s((exp as any).title), // Alias: title -> role
        dates: s(exp.dates) ||
            s(exp.dateRange?.displayString) ||
            ((exp as any).startDate
                ? `${s((exp as any).startDate)} - ${s((exp as any).endDate) || 'Present'}`
                : ''),
        dateRange: exp.dateRange,
        tasks: Array.isArray(exp.tasks) ? exp.tasks.map(s) : [],
    }));

    // Sprint 6.2: Normalize educations with robust key aliasing
    // App may use: degree, diploma, title, name
    // App may use: school, institution, establishment, company
    // App may use: year, endYear, graduationYear, dateEnd, dateFin
    const normalizedEducations = (profile.educations || []).map((edu) => {
        const raw = edu as any; // For aliasing
        return {
            degree: s(edu.degree) || s(raw.diploma) || s(raw.title) || s(raw.name),
            school: s(edu.school) || s(raw.institution) || s(raw.establishment) || s(raw.company),
            year: s(edu.year) || s(raw.endYear) || s(raw.graduationYear) || s(raw.dateEnd) || s(raw.dateFin),
        };
    });

    return {
        id: profile.id,
        personal: {
            firstName: s(profile.personal?.firstName),
            lastName: s(profile.personal?.lastName),
            title: s(profile.personal?.title),
            photoUrl: profile.personal?.photoUrl,
            // Preserve nested contact structure (buildScene expects this)
            contact: {
                email: s(profile.personal?.contact?.email),
                phone: s(profile.personal?.contact?.phone),
                address: s(profile.personal?.contact?.address),
            },
        },
        summary: s(profile.summary),
        skills: (profile.skills || []).map(s),
        languages: (profile.languages || []).map((l) => ({
            name: s(l.name),
            level: s(l.level),
        })),
        experiences: normalizedExperiences,
        educations: normalizedEducations,
    };
}

// ============================================================================
// DESIGN ADAPTER
// ============================================================================

/**
 * Map app DesignConfig to NEXAL2 design format.
 * DesignConfig comes from useDesign() hook (store.design state).
 */
export function mapDesignToNexal2(design: Partial<DesignConfig> | undefined): Nexal2Design {
    return {
        paperFormat: design?.paperFormat || 'A4',
        accentColor: design?.accentColor || '#4F46E5',
        fontPair: design?.fontPairing || 'sans',
        showPhoto: design?.showPhoto !== false,
        sidebarPosition: design?.sidebarPosition || 'left',
        headerStyle: (design?.headerStyle as 'classic' | 'modern' | 'minimal') || 'classic',
    };
}

// ============================================================================
// COMBINED ADAPTER
// ============================================================================

/**
 * Combined adapter: maps both profile and design in one call.
 *
 * @param profile - CVProfile from useProfile()
 * @param design - DesignConfig from useDesign()
 */
export function mapAppToNexal2(
    profile: CVProfile | undefined,
    design: Partial<DesignConfig> | undefined
): { profile: Nexal2Profile; design: Nexal2Design } {
    return {
        profile: mapProfileToNexal2(profile),
        design: mapDesignToNexal2(design),
    };
}

export default mapAppToNexal2;
</file>

<file path="components/index.ts">
/**
 * NEXAL2 Components Index
 */

export { NEXAL2PreviewPane } from './NEXAL2PreviewPane';
</file>

<file path="components/NEXAL2PreviewPane.tsx">
/**
 * NEXAL2 Preview Pane
 *
 * Drop-in replacement for PreviewPane when NEXAL2 engine is enabled.
 * Uses the NEXAL2 rendering pipeline:
 * - createConstraints(region, preset, options)
 * - buildScene(profile, design)
 * - computeLayout(scene, constraints)
 * - HTMLRenderer for preview
 * - PDFRenderer for export
 * 
 * Phase 4.1: CV Chameleon with region/preset controls.
 */

import React, { useMemo, useState, useCallback, useRef } from 'react';
import { pdf } from '@react-pdf/renderer';
import {
    Loader2, RefreshCw, Download, AlertTriangle,
    Camera, CameraOff, PanelLeft, PanelRight,
    ZoomIn, ZoomOut, Maximize, Globe, Layout
} from 'lucide-react';
import { useProfile, useDesign, useCVStoreV2 } from '@/application/store/v2';
import { useUIStore } from '@/application/store/ui-store';
import { useToastStore } from '@/application/store/toast-store';
import {
    buildScene,
    computeLayout,
    createConstraints,
    getRegionIds,
    getPresetIds,
    HTMLRenderer,
    EditableHTMLRenderer,
    PDFRenderer,
    mapAppToNexal2,
    runAndLogMatrix,
    runAndLogLongProfileTests,
    runAndLogPaginationMatrix,
    type RegionId,
    type PresetId,
    type ChameleonConstraints,
} from '@/nexal2';
import { StructurePanel } from './StructurePanel';
import type { LayoutNode } from '../types';

// PT to PX conversion for sizing
const PT_TO_PX = 96 / 72;

interface NEXAL2PreviewPaneProps {
    initialScale?: number;
}

export const NEXAL2PreviewPane: React.FC<NEXAL2PreviewPaneProps> = ({
    initialScale = 0.6,
}) => {
    const profile = useProfile();
    const design = useDesign();
    const { setGeneratingPDF } = useUIStore();
    const { addToast } = useToastStore();

    // Store actions for toggles
    const setShowPhoto = useCVStoreV2((state) => state.setShowPhoto);
    const setDesign = useCVStoreV2((state) => state.setDesign);

    // State
    const [isDownloading, setIsDownloading] = useState(false);
    const [scale, setScale] = useState(initialScale);
    const scrollContainerRef = useRef<HTMLDivElement>(null);

    // Chameleon state (region + preset)
    const [regionId, setRegionId] = useState<RegionId>('FR');
    const [presetId, setPresetId] = useState<PresetId>('SIDEBAR');

    // Create constraints from region + preset FIRST
    const constraints: ChameleonConstraints = useMemo(() => {
        const c = createConstraints({
            regionId,
            presetId,
            sidebarPosition: design?.sidebarPosition || 'left',
        });

        // DEBUG: Frame gap instrumentation
        if (c.frames.sidebar) {
            const sb = c.frames.sidebar;
            const delta = c.paper.width - (sb.x + sb.width);
            console.log('[NEXAL2 GAP DEBUG]', {
                preset: presetId,
                sidebarPosition: c.sidebarPosition,
                paperWidth: c.paper.width,
                sidebarX: sb.x,
                sidebarWidth: sb.width,
                sidebarRightEdge: sb.x + sb.width,
                deltaPt: delta,
                gapPx: delta * (96 / 72),
            });
            if (Math.abs(delta) > 0.01) {
                console.warn('[NEXAL2] SIDEBAR FRAME GAP DETECTED:', delta, 'pt');
            }
        }

        return c;
    }, [regionId, presetId, design?.sidebarPosition]);

    // Paper dimensions from constraints
    const paper = constraints.paper;

    // Photo policy enforcement based on region + preset
    const photoPolicy = useMemo(() => {
        // Use supportsPhoto from constraints (set by preset)
        const isPhotoDiscouraged = constraints.atsMode;
        const presetSupportsPhoto = constraints.supportsPhoto;
        const canShowPhoto = presetSupportsPhoto && !isPhotoDiscouraged;
        return {
            canShowPhoto,
            isDiscouraged: isPhotoDiscouraged,
            presetSupportsPhoto,
        };
    }, [constraints.atsMode, constraints.supportsPhoto]);

    // Effective showPhoto (respects policy)
    const effectiveShowPhoto = useMemo(() => {
        if (!photoPolicy.canShowPhoto) return false;
        return design?.showPhoto ?? true;
    }, [photoPolicy.canShowPhoto, design?.showPhoto]);

    // Map app data to NEXAL2 format (with synced paperFormat and photo policy)
    const { profile: nexal2Profile, design: nexal2Design } = useMemo(() => {
        const mapped = mapAppToNexal2(profile, design);
        // SYNC: override paperFormat from constraints (region) to prevent mismatch
        const syncedDesign = {
            ...mapped.design,
            paperFormat: constraints.paperFormat,
            showPhoto: effectiveShowPhoto,
        };
        console.log('[NEXAL2] regionId=', regionId, 'presetId=', presetId, 'paperFormat=', syncedDesign.paperFormat);
        console.log('[NEXAL2] effectiveShowPhoto=', effectiveShowPhoto, '(policy:', photoPolicy, ')');
        return { profile: mapped.profile, design: syncedDesign };
    }, [profile, design, constraints.paperFormat, effectiveShowPhoto, regionId, presetId, photoPolicy]);

    // Build scene with synced design
    const scene = useMemo(() => {
        return buildScene(nexal2Profile, nexal2Design);
    }, [nexal2Profile, nexal2Design]);

    // Compute layout using constraints
    const layout = useMemo(() => {
        return computeLayout(scene, constraints as any);
    }, [scene, constraints]);

    // Overflow detection - P0 FIX: Only show overflow if pagination DID NOT fix it
    const overflowInfo = useMemo(() => {
        const margins = constraints.margins;
        const didPaginate = layout.paginationMeta?.didPaginate ?? false;
        const pageCount = layout.pages.length;

        // If we have multiple pages, content was successfully paginated - no overflow
        if (didPaginate && pageCount > 1) {
            return { isOverflowing: false, overflowAmount: 0, maxY: 0 };
        }

        // Single page - check if content exceeds page bounds
        let maxY = 0;
        const walk = (n: LayoutNode) => {
            const nodeBottom = n.frame.y + n.frame.height;
            if (nodeBottom > maxY) maxY = nodeBottom;
            n.children?.forEach(walk);
        };
        layout.pages[0]?.children?.forEach(walk); // Only check first page content

        const isOverflowing = maxY > paper.height - margins.bottom;
        const overflowAmount = maxY - (paper.height - margins.bottom);

        if (isOverflowing) {
            console.warn(`[NEXAL2] OVERFLOW: content=${maxY.toFixed(0)}pt, max=${(paper.height - margins.bottom).toFixed(0)}pt`);
        }

        return { isOverflowing, overflowAmount, maxY };
    }, [layout, paper, constraints.margins]);

    // Compute layout signature (independent of scale)
    const layoutSignature = useMemo(() => {
        const flat: Array<[string, number, number, number, number, string]> = [];
        const walk = (n: LayoutNode) => {
            flat.push([
                n.nodeId,
                Math.round(n.frame.x), Math.round(n.frame.y),
                Math.round(n.frame.width), Math.round(n.frame.height),
                n.nodeType
            ]);
            n.children?.forEach(walk);
        };
        layout.pages.forEach(walk);
        const json = JSON.stringify(flat);
        let hash = 0;
        for (let i = 0; i < json.length; i++) {
            const char = json.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(16).toUpperCase().padStart(8, '0').slice(0, 8);
    }, [layout]);

    // Zoom handlers
    const handleZoomIn = useCallback(() => setScale(s => Math.min(s + 0.1, 1.5)), []);
    const handleZoomOut = useCallback(() => setScale(s => Math.max(s - 0.1, 0.3)), []);
    const handleZoomReset = useCallback(() => setScale(0.6), []);
    const handleFitWidth = useCallback(() => {
        if (scrollContainerRef.current) {
            const containerWidth = scrollContainerRef.current.clientWidth - 32;
            const pageWidthPx = paper.width * PT_TO_PX;
            const newScale = Math.min(containerWidth / pageWidthPx, 1.0);
            setScale(Math.max(0.3, newScale));
        }
    }, [paper.width]);

    // Toggle handlers
    const handleTogglePhoto = useCallback(() => {
        const newValue = !design?.showPhoto;
        console.log('[NEXAL2] Toggling showPhoto to:', newValue);
        setShowPhoto(newValue);
    }, [design?.showPhoto, setShowPhoto]);

    const handleToggleSidebar = useCallback(() => {
        const newPos = design?.sidebarPosition === 'left' ? 'right' : 'left';
        console.log('[NEXAL2] Toggling sidebarPosition to:', newPos);
        setDesign({ sidebarPosition: newPos });
    }, [design?.sidebarPosition, setDesign]);

    // Region/Preset cycle handlers
    const handleCycleRegion = useCallback(() => {
        const regions = getRegionIds();
        const idx = regions.indexOf(regionId);
        const next = regions[(idx + 1) % regions.length];
        console.log(`[NEXAL2] Region: ${regionId} â†’ ${next}`);
        setRegionId(next);
    }, [regionId]);

    const handleCyclePreset = useCallback(() => {
        const presets = getPresetIds();
        const idx = presets.indexOf(presetId);
        const next = presets[(idx + 1) % presets.length];
        console.log(`[NEXAL2] Preset: ${presetId} â†’ ${next}`);
        setPresetId(next);
    }, [presetId]);

    // Dev: Run validation matrix
    const handleRunMatrix = useCallback(() => {
        const summary = runAndLogMatrix(profile, design);
        if (summary.failed > 0) {
            addToast(`Matrix: ${summary.failed}/${summary.total} failed`, 'error');
        } else {
            addToast(`Matrix: ${summary.passed}/${summary.total} passed âœ“`, 'success');
        }
    }, [profile, design, addToast]);

    // Dev: Run pagination tests with long profile
    const handleRunPaginationTests = useCallback(() => {
        runAndLogLongProfileTests();
        addToast('Pagination tests completed - see console', 'success');
    }, [addToast]);

    // Dev: Run full pagination matrix (Phase 4.8)
    const handleRunPaginationMatrix = useCallback(() => {
        runAndLogPaginationMatrix();
        addToast('Pagination matrix completed - see console', 'success');
    }, [addToast]);

    // Download PDF handler
    const handleDownloadPDF = useCallback(async () => {
        setIsDownloading(true);
        setGeneratingPDF(true);
        try {
            console.log(`[NEXAL2] Export PDF sig=${layoutSignature} region=${regionId} preset=${presetId}`);
            const pdfDoc = <PDFRenderer layout={layout} title="CV-NEXAL2" layoutSignature={layoutSignature} margins={constraints.margins} />;
            const blob = await pdf(pdfDoc).toBlob();
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const firstName = profile?.personal?.firstName || 'CV';
            const lastName = profile?.personal?.lastName || '';
            link.download = `${firstName}_${lastName}_CV.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            addToast('PDF tÃ©lÃ©chargÃ© avec succÃ¨s', 'success');
        } catch (error) {
            console.error('[NEXAL2] PDF download error:', error);
            addToast('Erreur de tÃ©lÃ©chargement PDF', 'error');
        } finally {
            setIsDownloading(false);
            setGeneratingPDF(false);
        }
    }, [layout, layoutSignature, profile, regionId, presetId, addToast, setGeneratingPDF]);

    // Loading state
    if (!profile) {
        return (
            <div className="w-full h-full min-h-0 flex items-center justify-center bg-slate-800/50 rounded-xl">
                <div className="text-slate-400 text-center">
                    <Loader2 className="animate-spin mx-auto mb-2" size={24} />
                    <span>Chargement du profil...</span>
                </div>
            </div>
        );
    }

    return (
        <div className="w-full h-full min-h-0 flex flex-col relative">
            {/* Toolbar - Top Right */}
            <div className="absolute top-2 right-2 z-10 flex gap-2">
                {/* Engine Badge */}
                <div className="px-2 py-1 bg-indigo-600/80 backdrop-blur-sm text-white text-[10px] rounded-full">
                    NEXAL2
                </div>

                {/* Zoom Controls */}
                <div className="flex items-center gap-1 px-1 py-0.5 bg-slate-700/80 backdrop-blur-sm rounded-full border border-slate-600">
                    <button onClick={handleZoomOut} className="p-1 hover:bg-slate-600 rounded" title="Zoom Out">
                        <ZoomOut size={12} className="text-slate-300" />
                    </button>
                    <span className="text-[10px] text-slate-300 w-8 text-center">{Math.round(scale * 100)}%</span>
                    <button onClick={handleZoomIn} className="p-1 hover:bg-slate-600 rounded" title="Zoom In">
                        <ZoomIn size={12} className="text-slate-300" />
                    </button>
                    <button onClick={handleFitWidth} className="p-1 hover:bg-slate-600 rounded border-l border-slate-600" title="Fit Width">
                        <Maximize size={12} className="text-slate-300" />
                    </button>
                </div>

                {/* Download Button */}
                <button
                    onClick={handleDownloadPDF}
                    disabled={isDownloading}
                    className="flex items-center gap-1 px-2 py-1 bg-emerald-600/80 backdrop-blur-sm text-white text-[10px] rounded-full hover:bg-emerald-500 disabled:opacity-50"
                >
                    {isDownloading ? (
                        <RefreshCw className="animate-spin" size={10} />
                    ) : (
                        <Download size={10} />
                    )}
                    PDF
                </button>
            </div>

            {/* Dev Controls - Bottom Left */}
            <div className="absolute bottom-2 left-2 z-10 flex flex-col gap-1">
                {/* Region Toggle */}
                <button
                    onClick={handleCycleRegion}
                    className="flex items-center gap-1 px-2 py-1 bg-purple-600/80 backdrop-blur-sm text-white text-[10px] rounded-full border border-purple-500 hover:bg-purple-500"
                    title={`Region: ${regionId}`}
                >
                    <Globe size={10} />
                    {regionId} ({constraints.paperFormat})
                </button>

                {/* Preset Toggle */}
                <button
                    onClick={handleCyclePreset}
                    className="flex items-center gap-1 px-2 py-1 bg-orange-600/80 backdrop-blur-sm text-white text-[10px] rounded-full border border-orange-500 hover:bg-orange-500"
                    title={`Preset: ${presetId}`}
                >
                    <Layout size={10} />
                    {presetId}
                </button>

                {/* Photo Toggle - disabled when preset doesn't support photo */}
                <button
                    onClick={photoPolicy.canShowPhoto ? handleTogglePhoto : undefined}
                    disabled={!photoPolicy.canShowPhoto}
                    className={`flex items-center gap-1 px-2 py-1 backdrop-blur-sm text-[10px] rounded-full border ${!photoPolicy.canShowPhoto
                        ? 'bg-slate-800/60 text-slate-500 border-slate-700 cursor-not-allowed opacity-60'
                        : effectiveShowPhoto
                            ? 'bg-blue-600/80 text-white border-blue-500 hover:bg-blue-500'
                            : 'bg-slate-700/80 text-slate-300 border-slate-600 hover:bg-slate-600'
                        }`}
                    title={
                        !photoPolicy.canShowPhoto
                            ? `Photo disabled: ${photoPolicy.isDiscouraged ? 'ATS/US region discourages photos' : 'This preset does not support photo placement'}`
                            : `Photo: ${effectiveShowPhoto ? 'ON' : 'OFF'} (click to toggle)`
                    }
                >
                    {effectiveShowPhoto && photoPolicy.canShowPhoto ? <Camera size={10} /> : <CameraOff size={10} />}
                    Photo {!photoPolicy.canShowPhoto && 'âŠ˜'}
                </button>

                {/* Sidebar Position Toggle (only for SIDEBAR preset) */}
                {presetId === 'SIDEBAR' && (
                    <button
                        onClick={handleToggleSidebar}
                        className="flex items-center gap-1 px-2 py-1 bg-slate-700/80 backdrop-blur-sm text-slate-300 text-[10px] rounded-full border border-slate-600 hover:bg-slate-600"
                        title={`Sidebar: ${design?.sidebarPosition?.toUpperCase()}`}
                    >
                        {design?.sidebarPosition === 'left' ? <PanelLeft size={10} /> : <PanelRight size={10} />}
                        {design?.sidebarPosition?.toUpperCase()}
                    </button>
                )}

                {/* Matrix Validation Button */}
                <button
                    onClick={handleRunMatrix}
                    className="flex items-center gap-1 px-2 py-1 bg-cyan-600/80 backdrop-blur-sm text-white text-[10px] rounded-full border border-cyan-500 hover:bg-cyan-500"
                    title="Run validation matrix on all region/preset combinations"
                >
                    âš¡ Matrix
                </button>

                {/* Pagination Test Button */}
                <button
                    onClick={handleRunPaginationTests}
                    className="flex items-center gap-1 px-2 py-1 bg-emerald-600/80 backdrop-blur-sm text-white text-[10px] rounded-full border border-emerald-500 hover:bg-emerald-500"
                    title="Run pagination tests with long profile"
                >
                    ðŸ“„ Pagination
                </button>

                {/* Phase 4.8: Pagination Matrix Button */}
                <button
                    onClick={handleRunPaginationMatrix}
                    className="flex items-center gap-1 px-2 py-1 bg-purple-600/80 backdrop-blur-sm text-white text-[10px] rounded-full border border-purple-500 hover:bg-purple-500"
                    title="Run full pagination matrix (6 regions Ã— 6 presets Ã— 3 profiles)"
                >
                    ðŸ“„âš¡ Matrix+Paginate
                </button>
            </div>

            {/* Overflow Warning - Top Left */}
            {overflowInfo.isOverflowing && (
                <div className="absolute top-2 left-2 z-10">
                    <div className="flex items-center gap-1 px-2 py-1 bg-amber-600/90 backdrop-blur-sm text-white text-[10px] rounded-full animate-pulse">
                        <AlertTriangle size={10} />
                        Overflow: +{Math.round(overflowInfo.overflowAmount)}pt
                    </div>
                </div>
            )}

            {/* Signature + Constraints Badge - Bottom Right */}
            <div className="absolute bottom-2 right-2 z-10 flex flex-col gap-1 items-end">
                <div className="px-2 py-1 bg-slate-800/80 backdrop-blur-sm text-slate-400 text-[9px] rounded font-mono">
                    Sig: {layoutSignature}
                </div>
                <div className="px-2 py-1 bg-slate-800/80 backdrop-blur-sm text-slate-500 text-[8px] rounded">
                    {paper.width}Ã—{paper.height}pt â€¢ {constraints.density}
                </div>
            </div>

            {/* STRUCTURE MODE PANEL - Phase 7.1 */}
            {/* TASK B: Consolidated Dev Dock - Single container with vertical stacking */}
            <div className="absolute bottom-2 left-2 z-20 flex flex-col gap-2 max-w-xs">
                {/* Structure Panel */}
                <StructurePanel />

                {/* DEBUG PANEL (dev only) - Collapsible profile inspector */}
                {import.meta.env.DEV && (
                    <details className="max-h-48 overflow-auto text-[9px] bg-slate-900/95 border border-slate-700 rounded p-2">
                        <summary className="cursor-pointer text-amber-400 font-bold">Debug Profile</summary>
                        <div className="mt-1 text-slate-300 space-y-1">
                            <div><strong>personal.firstName:</strong> {profile?.personal?.firstName || 'âˆ…'}</div>
                            <div><strong>personal.lastName:</strong> {profile?.personal?.lastName || 'âˆ…'}</div>
                            <div><strong>personal.title:</strong> {profile?.personal?.title || 'âˆ…'}</div>
                            <div><strong>personal.contact.email:</strong> {profile?.personal?.contact?.email || 'âˆ…'}</div>
                            <div><strong>personal.contact.phone:</strong> {profile?.personal?.contact?.phone || 'âˆ…'}</div>
                            <div><strong>personal.contact.address:</strong> {String(profile?.personal?.contact?.address || 'âˆ…')}</div>
                            <div><strong>experiences.length:</strong> {profile?.experiences?.length || 0}</div>
                            <div><strong>educations.length:</strong> {profile?.educations?.length || 0}</div>
                            <div><strong>skills.length:</strong> {profile?.skills?.length || 0}</div>
                            <div><strong>languages.length:</strong> {profile?.languages?.length || 0}</div>

                            {/* RAW education data (before adapter) */}
                            {profile?.educations?.[0] && (
                                <div className="border-t border-slate-700 pt-1">
                                    <strong className="text-orange-400">RAW educations[0] keys:</strong> {Object.keys(profile.educations[0]).join(', ')}
                                    <div className="text-[8px] text-slate-400">
                                        {JSON.stringify(profile.educations[0], null, 0).slice(0, 150)}...
                                    </div>
                                </div>
                            )}

                            {/* MAPPED education data (after adapter) */}
                            {nexal2Profile?.educations?.[0] && (
                                <div className="border-t border-slate-700 pt-1">
                                    <strong className="text-green-400">MAPPED edu[0]:</strong>
                                    degree="{nexal2Profile.educations[0].degree || 'âˆ…'}"
                                    school="{nexal2Profile.educations[0].school || 'âˆ…'}"
                                    year="{nexal2Profile.educations[0].year || 'âˆ…'}"
                                </div>
                            )}

                            <div><strong>layout.pages.length:</strong> {layout?.pages?.length || 0}</div>
                        </div>
                    </details>
                )}
            </div>

            {/* CV Preview - Multi-page stacking */}
            <div
                ref={scrollContainerRef}
                className="flex-1 min-h-0 overflow-auto p-4 bg-slate-900/50"
            >
                <div className="mx-auto w-fit">
                    <div
                        style={{
                            boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                            borderRadius: 4,
                            // REMOVED overflow: hidden - was clipping multi-page content
                        }}
                    >
                        <EditableHTMLRenderer
                            layout={layout}
                            scale={scale}
                            debug={false}
                            layoutSignature={layoutSignature}
                            margins={constraints.margins}
                        />
                    </div>
                </div>
            </div>
        </div>
    );
};

export default NEXAL2PreviewPane;
</file>

<file path="components/StructurePanel.tsx">
/**
 * Phase 7.1 - Structure Panel
 * 
 * Collapsible panel for section ordering, visibility, and limits.
 * Uses HTML5 Drag and Drop for reordering.
 */

import React, { useState, useCallback } from 'react';
import { useCVStoreV2 } from '@/application/store/v2/cv-store-v2';
import {
    DEFAULT_STRUCTURE,
    type StructureConfig,
    type SectionId
} from '@/application/store/v2/cv-store-v2.types';
import { Eye, EyeOff, GripVertical, Settings2 } from 'lucide-react';

/** Section display names */
const SECTION_LABELS: Record<SectionId, string> = {
    identity: 'IdentitÃ©',
    contact: 'Contact',
    summary: 'RÃ©sumÃ©',
    skills: 'CompÃ©tences',
    languages: 'Langues',
    experiences: 'ExpÃ©riences',
    educations: 'Formation',
};

interface StructurePanelProps {
    className?: string;
}

export const StructurePanel: React.FC<StructurePanelProps> = ({ className }) => {
    const design = useCVStoreV2((state) => state.design);
    const setDesign = useCVStoreV2((state) => state.setDesign);

    // Local state for DnD
    const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
    const [showAdvanced, setShowAdvanced] = useState(false);

    // Get structure config with defaults
    const structure: StructureConfig = {
        ...DEFAULT_STRUCTURE,
        ...design?.structure,
        visible: { ...DEFAULT_STRUCTURE.visible, ...design?.structure?.visible },
        limits: { ...DEFAULT_STRUCTURE.limits, ...design?.structure?.limits },
    };

    // Update structure in store
    const updateStructure = useCallback((updates: Partial<StructureConfig>) => {
        setDesign({
            structure: {
                ...structure,
                ...updates,
            },
        });
    }, [structure, setDesign]);

    // Toggle section visibility
    const toggleVisibility = useCallback((sectionId: SectionId) => {
        updateStructure({
            visible: {
                ...structure.visible,
                [sectionId]: !structure.visible[sectionId],
            },
        });
    }, [structure, updateStructure]);

    // Update limit
    const updateLimit = useCallback((key: keyof StructureConfig['limits'], value: number) => {
        updateStructure({
            limits: {
                ...structure.limits,
                [key]: Math.max(1, Math.min(99, value)),
            },
        });
    }, [structure, updateStructure]);

    // DnD handlers
    const handleDragStart = useCallback((e: React.DragEvent, index: number) => {
        setDraggedIndex(index);
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(index));
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    }, []);

    const handleDrop = useCallback((e: React.DragEvent, targetIndex: number) => {
        e.preventDefault();
        if (draggedIndex === null || draggedIndex === targetIndex) return;

        const newOrder = [...structure.order];
        const [removed] = newOrder.splice(draggedIndex, 1);
        newOrder.splice(targetIndex, 0, removed);

        updateStructure({ order: newOrder });
        setDraggedIndex(null);
    }, [draggedIndex, structure, updateStructure]);

    const handleDragEnd = useCallback(() => {
        setDraggedIndex(null);
    }, []);

    // Limits summary
    const limitsText = `${structure.limits.skillsTopN}/${structure.limits.languagesTopN}/${structure.limits.experiencesTopN}/${structure.limits.tasksTopN}/${structure.limits.educationsTopN}`;
    const isDefaultLimits = limitsText === '12/6/5/4/4';

    return (
        <details className={`text-[10px] bg-slate-900/95 border border-slate-700 rounded p-2 ${className || ''}`}>
            <summary className="cursor-pointer text-cyan-400 font-bold flex items-center gap-1">
                <Settings2 size={12} />
                Structure Mode
            </summary>

            <div className="mt-2 space-y-2">
                {/* Section list with DnD */}
                <div className="space-y-1">
                    {structure.order.map((sectionId, index) => (
                        <div
                            key={sectionId}
                            draggable
                            onDragStart={(e) => handleDragStart(e, index)}
                            onDragOver={handleDragOver}
                            onDrop={(e) => handleDrop(e, index)}
                            onDragEnd={handleDragEnd}
                            className={`flex items-center gap-1 px-1 py-0.5 rounded border transition-colors ${draggedIndex === index
                                    ? 'border-cyan-500 bg-cyan-900/30'
                                    : 'border-slate-700 bg-slate-800/50 hover:border-slate-600'
                                }`}
                        >
                            {/* Drag handle */}
                            <GripVertical
                                size={12}
                                className="text-slate-500 cursor-grab flex-shrink-0"
                            />

                            {/* Section name */}
                            <span className={`flex-1 ${structure.visible[sectionId] ? 'text-slate-200' : 'text-slate-500 line-through'
                                }`}>
                                {SECTION_LABELS[sectionId]}
                            </span>

                            {/* Visibility toggle */}
                            <button
                                onClick={() => toggleVisibility(sectionId)}
                                className={`p-0.5 rounded ${structure.visible[sectionId]
                                        ? 'text-emerald-400 hover:bg-emerald-900/30'
                                        : 'text-slate-500 hover:bg-slate-700'
                                    }`}
                                title={structure.visible[sectionId] ? 'Masquer' : 'Afficher'}
                            >
                                {structure.visible[sectionId] ? <Eye size={12} /> : <EyeOff size={12} />}
                            </button>
                        </div>
                    ))}
                </div>

                {/* Limits summary / Advanced toggle */}
                <div className="border-t border-slate-700 pt-2">
                    <div className="flex items-center justify-between">
                        <span className="text-slate-400">
                            Limites: {isDefaultLimits ? 'dÃ©faut' : limitsText}
                        </span>
                        <button
                            onClick={() => setShowAdvanced(!showAdvanced)}
                            className="text-[9px] text-cyan-400 hover:text-cyan-300"
                        >
                            {showAdvanced ? 'â–¼ Masquer' : 'â–¶ AvancÃ©'}
                        </button>
                    </div>

                    {/* Advanced limits controls */}
                    {showAdvanced && (
                        <div className="mt-2 space-y-1 text-[9px]">
                            {([
                                ['skillsTopN', 'Skills max'],
                                ['languagesTopN', 'Langues max'],
                                ['experiencesTopN', 'ExpÃ©riences max'],
                                ['tasksTopN', 'TÃ¢ches/exp max'],
                                ['educationsTopN', 'Formations max'],
                            ] as const).map(([key, label]) => (
                                <div key={key} className="flex items-center justify-between">
                                    <span className="text-slate-400">{label}</span>
                                    <input
                                        type="number"
                                        min={1}
                                        max={99}
                                        value={structure.limits[key]}
                                        onChange={(e) => updateLimit(key, parseInt(e.target.value) || 1)}
                                        className="w-12 px-1 py-0.5 bg-slate-800 border border-slate-600 rounded text-slate-200 text-center"
                                    />
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </details>
    );
};

export default StructurePanel;
</file>

<file path="constraints/createConstraints.ts">
/**
 * NEXAL2 - Constraints Builder
 * 
 * Creates a complete constraints object from region + preset + options.
 * This is the main entry point for the Chameleon system.
 * 
 * Flow: region â†’ paper + margins + density â†’ preset â†’ frames â†’ tokens â†’ LayoutConstraints
 */

import { getRegion, type RegionId, type Density } from './regions';
import { computePresetFrames, type PresetId, type PresetOptions, type LayoutFrames } from './presets';
import { PAPER_DIMENSIONS } from '../types';

// ============================================================================
// TYPES
// ============================================================================

export interface SpacingTokens {
    sectionGap: number;      // Gap between sections (pt)
    subsectionGap: number;   // Gap within sections (pt)
    lineHeight: number;      // Line height multiplier
    fontSize: {
        body: number;
        heading: number;
        subheading: number;
        small: number;
    };
}

export interface ChameleonConstraints {
    // Paper
    paper: { width: number; height: number };
    paperFormat: 'A4' | 'LETTER';

    // Margins (from region)
    margins: { top: number; right: number; bottom: number; left: number };

    // Frames (from preset)
    frames: LayoutFrames;

    // Layout options
    sidebarPosition: 'left' | 'right';
    sidebarWidth: number;
    sidebarGap: number;

    // Tokens (from density)
    tokens: SpacingTokens;

    // Metadata
    regionId: RegionId;
    presetId: PresetId;
    density: Density;
    atsMode: boolean;
    supportsPhoto: boolean;  // Phase 4.2: Whether preset has photo placement
}

export interface CreateConstraintsOptions {
    regionId?: RegionId | string;
    presetId?: PresetId;
    sidebarPosition?: 'left' | 'right';
    sidebarWidth?: number;
    sidebarGap?: number;
    headerHeight?: number;
    overrides?: Partial<ChameleonConstraints>;
}

// ============================================================================
// DENSITY â†’ TOKENS
// ============================================================================

const DENSITY_TOKENS: Record<Density, SpacingTokens> = {
    compact: {
        sectionGap: 12,
        subsectionGap: 6,
        lineHeight: 1.3,
        fontSize: { body: 9, heading: 12, subheading: 10, small: 7 },
    },
    normal: {
        sectionGap: 16,
        subsectionGap: 8,
        lineHeight: 1.4,
        fontSize: { body: 10, heading: 14, subheading: 11, small: 8 },
    },
    airy: {
        sectionGap: 24,
        subsectionGap: 12,
        lineHeight: 1.6,
        fontSize: { body: 11, heading: 16, subheading: 12, small: 9 },
    },
};

// ============================================================================
// MAIN FUNCTION
// ============================================================================

/**
 * Create complete layout constraints from region + preset + options.
 * 
 * @example
 * const constraints = createConstraints({ regionId: 'US', presetId: 'ATS_ONE_COLUMN' });
 * const constraints = createConstraints({ regionId: 'FR', presetId: 'SIDEBAR', sidebarPosition: 'right' });
 */
export function createConstraints(options: CreateConstraintsOptions = {}): ChameleonConstraints {
    // 1. Load region profile
    const regionId = (options.regionId || 'FR') as RegionId;
    const region = getRegion(regionId);

    // 2. Get paper dimensions
    const paper = PAPER_DIMENSIONS[region.paperFormat];

    // 3. Determine preset (ATS regions default to ATS_ONE_COLUMN)
    let presetId = options.presetId || (region.atsDefault ? 'ATS_ONE_COLUMN' : 'SIDEBAR');

    // 4. Build preset options
    const presetOptions: PresetOptions = {
        sidebarPosition: options.sidebarPosition || 'left',
        sidebarWidth: options.sidebarWidth || 160,
        sidebarGap: options.sidebarGap || 20,
        headerHeight: options.headerHeight || 120,
    };

    // 5. Compute frames from preset
    const presetResult = computePresetFrames(
        presetId as PresetId,
        paper,
        region.margins,
        presetOptions
    );

    // 6. Get tokens from density
    const tokens = { ...DENSITY_TOKENS[region.density] };

    // 7. Build final constraints
    const constraints: ChameleonConstraints = {
        paper,
        paperFormat: region.paperFormat,
        margins: { ...region.margins },
        frames: presetResult.frames,
        sidebarPosition: presetOptions.sidebarPosition || 'left',
        sidebarWidth: presetOptions.sidebarWidth || 160,
        sidebarGap: presetOptions.sidebarGap || 20,
        tokens,
        regionId,
        presetId: presetId as PresetId,
        density: region.density,
        atsMode: region.atsDefault,
        supportsPhoto: presetResult.supportsPhoto,
    };

    // 8. Apply overrides
    if (options.overrides) {
        Object.assign(constraints, options.overrides);
    }

    return constraints;
}

/**
 * Backwards-compatible wrapper for existing code.
 * Maps old signature to new createConstraints.
 */
export function createDefaultConstraints(
    format: 'A4' | 'LETTER' = 'A4',
    sidebarPosition: 'left' | 'right' = 'left'
): ChameleonConstraints {
    // Map format to region (A4 â†’ FR, LETTER â†’ US)
    const regionId = format === 'LETTER' ? 'US' : 'FR';

    return createConstraints({
        regionId,
        presetId: 'SIDEBAR',
        sidebarPosition,
    });
}

export default createConstraints;
</file>

<file path="constraints/index.ts">
/**
 * NEXAL2 - Constraints Module
 * 
 * CV Chameleon constraint system: regions, presets, frames.
 */

// Regions
export {
    REGIONS,
    getRegion,
    getRegionIds,
    type RegionId,
    type RegionProfile,
    type PhotoPolicy,
    type Density
} from './regions';

// Presets
export {
    computePresetFrames,
    getPresetIds,
    type PresetId,
    type PresetOptions,
    type PresetResult,
    type Frame,
    type LayoutFrames
} from './presets';

// Constraints Builder
export {
    createConstraints,
    createDefaultConstraints,
    type ChameleonConstraints,
    type CreateConstraintsOptions,
    type SpacingTokens
} from './createConstraints';
</file>

<file path="constraints/presets.ts">
/**
 * NEXAL2 - Layout Presets
 * 
 * Presets define the structural layout: which frames exist and how they are positioned.
 * Each preset computes frames from (paper dimensions, safe area, options).
 * 
 * CV Chameleon: Multiple presets for different CV styles.
 * 
 * Phase 4.2: Added DUAL_SIDEBAR, LEFT_RAIL, SPLIT_HEADER presets.
 */

import type { RegionProfile } from './regions';

// ============================================================================
// TYPES
// ============================================================================

export type PresetId =
    | 'SIDEBAR'
    | 'TOP_HEADER'
    | 'SPLIT_HEADER'
    | 'LEFT_RAIL'
    | 'DUAL_SIDEBAR'
    | 'ATS_ONE_COLUMN';

export interface Frame {
    x: number;      // pt, absolute from page origin
    y: number;
    width: number;
    height: number;
}

export interface LayoutFrames {
    main: Frame;
    sidebar?: Frame;
    header?: Frame;
    // Phase 4.2: New frame types
    leftRail?: Frame;
    rightRail?: Frame;
    headerLeft?: Frame;
    headerRight?: Frame;
}

export interface PresetOptions {
    sidebarPosition?: 'left' | 'right';
    sidebarWidth?: number;  // pt
    sidebarGap?: number;    // pt
    headerHeight?: number;  // pt
    // Phase 4.2: New options
    leftRailWidth?: number;
    rightRailWidth?: number;
    railGap?: number;
    headerSplit?: number;   // 0-1, ratio for headerLeft width
}

export interface PresetResult {
    frames: LayoutFrames;
    options: PresetOptions;  // Resolved options
    supportsPhoto: boolean;  // Whether this preset has a photo placement
}

// ============================================================================
// PRESET IMPLEMENTATIONS
// ============================================================================

/**
 * SIDEBAR preset: Classic 2-column with left/right sidebar.
 * Photo supported (in sidebar).
 */
function computeSidebarFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
): PresetResult {
    const sidebarPosition = options.sidebarPosition || 'left';
    const sidebarWidth = options.sidebarWidth || 160;
    const sidebarGap = options.sidebarGap || 20;

    const safeHeight = paper.height;

    // Sidebar spans full height
    const sidebarX = sidebarPosition === 'left' ? 0 : paper.width - sidebarWidth;
    const sidebar: Frame = {
        x: sidebarX,
        y: 0,
        width: sidebarWidth,
        height: safeHeight,
    };

    // Main column: remaining width with margins
    const mainX = sidebarPosition === 'left'
        ? sidebarWidth + sidebarGap + margins.left
        : margins.left;
    const mainWidth = paper.width - sidebarWidth - sidebarGap - margins.left - margins.right;
    const main: Frame = {
        x: mainX,
        y: margins.top,
        width: mainWidth,
        height: safeHeight - margins.top - margins.bottom,
    };

    return {
        frames: { main, sidebar },
        options: { sidebarPosition, sidebarWidth, sidebarGap },
        supportsPhoto: true,
    };
}

/**
 * TOP_HEADER preset: Header at top, single main column below.
 * Phase 5.3: Slightly taller header (96pt) to allow proper photo size.
 */
function computeTopHeaderFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
): PresetResult {
    // Phase 5.3: Slightly taller header to allow real photo size
    const headerHeight = Math.min(options.headerHeight ?? 96, 110);

    // Header spans full width at top
    const header: Frame = {
        x: 0,
        y: 0,
        width: paper.width,
        height: headerHeight,
    };

    // Main column below header, with margins
    const main: Frame = {
        x: margins.left,
        y: headerHeight + margins.top,
        width: paper.width - margins.left - margins.right,
        height: paper.height - headerHeight - margins.top - margins.bottom,
    };

    return {
        frames: { main, header },
        options: { headerHeight },
        supportsPhoto: true,
    };
}

/**
 * SPLIT_HEADER preset: Header split into left/right blocks + main below.
 * Phase 5.3: Slightly taller header (96pt) for proper photo size.
 */
function computeSplitHeaderFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
): PresetResult {
    // Phase 5.3: Slightly taller header to allow real photo size
    const headerHeight = Math.min(options.headerHeight ?? 96, 110);
    // Phase 5.1: Left block larger (65%) for name/title, right smaller for photo/contacts
    const headerSplit = options.headerSplit || 0.65;
    const gap = 8;

    // Calculate split widths
    const totalHeaderWidth = paper.width;
    const headerLeftWidth = Math.floor((totalHeaderWidth - gap) * headerSplit);
    const headerRightWidth = totalHeaderWidth - headerLeftWidth - gap;

    const headerLeft: Frame = {
        x: 0,
        y: 0,
        width: headerLeftWidth,
        height: headerHeight,
    };

    const headerRight: Frame = {
        x: headerLeftWidth + gap,
        y: 0,
        width: headerRightWidth,
        height: headerHeight,
    };

    // Main column below header
    const main: Frame = {
        x: margins.left,
        y: headerHeight + margins.top,
        width: paper.width - margins.left - margins.right,
        height: paper.height - headerHeight - margins.top - margins.bottom,
    };

    return {
        frames: { main, headerLeft, headerRight },
        options: { headerHeight, headerSplit },
        supportsPhoto: true,
    };
}

/**
 * LEFT_RAIL preset: Thin left rail for icons/metadata + large main area.
 * Photo not supported (rail too narrow).
 */
function computeLeftRailFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
): PresetResult {
    const leftRailWidth = options.leftRailWidth || 90;
    const railGap = options.railGap || 15;

    const leftRail: Frame = {
        x: 0,
        y: 0,
        width: leftRailWidth,
        height: paper.height,
    };

    // Main column: remaining width with margins
    const mainX = leftRailWidth + railGap + margins.left;
    const mainWidth = paper.width - leftRailWidth - railGap - margins.left - margins.right;
    const main: Frame = {
        x: mainX,
        y: margins.top,
        width: mainWidth,
        height: paper.height - margins.top - margins.bottom,
    };

    return {
        frames: { main, leftRail },
        options: { leftRailWidth, railGap },
        supportsPhoto: false, // Rail too narrow for photo
    };
}

/**
 * DUAL_SIDEBAR preset: Main center + left mini sidebar + right mini sidebar.
 * Photo not supported (sidebars too narrow).
 */
function computeDualSidebarFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
): PresetResult {
    const leftRailWidth = options.leftRailWidth || 90;
    const rightRailWidth = options.rightRailWidth || 120;
    const railGap = options.railGap || 15;

    const leftRail: Frame = {
        x: 0,
        y: 0,
        width: leftRailWidth,
        height: paper.height,
    };

    const rightRail: Frame = {
        x: paper.width - rightRailWidth,
        y: 0,
        width: rightRailWidth,
        height: paper.height,
    };

    // Main column: center with margins
    const mainX = leftRailWidth + railGap + margins.left;
    const mainWidth = paper.width - leftRailWidth - rightRailWidth - (railGap * 2) - margins.left - margins.right;
    const main: Frame = {
        x: mainX,
        y: margins.top,
        width: Math.max(mainWidth, 100), // Ensure minimum width
        height: paper.height - margins.top - margins.bottom,
    };

    return {
        frames: { main, leftRail, rightRail },
        options: { leftRailWidth, rightRailWidth, railGap },
        supportsPhoto: false, // Rails too narrow for photo
    };
}

/**
 * ATS_ONE_COLUMN preset: Single column, no sidebar, larger margins.
 * Optimized for ATS (Applicant Tracking Systems).
 * Photo discouraged.
 */
function computeAtsOneColumnFrames(
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    _options: PresetOptions
): PresetResult {
    // ATS uses slightly larger margins for readability
    const atsMargins = {
        top: Math.max(margins.top, 50),
        right: Math.max(margins.right, 50),
        bottom: Math.max(margins.bottom, 50),
        left: Math.max(margins.left, 50),
    };

    const main: Frame = {
        x: atsMargins.left,
        y: atsMargins.top,
        width: paper.width - atsMargins.left - atsMargins.right,
        height: paper.height - atsMargins.top - atsMargins.bottom,
    };

    return {
        frames: { main },
        options: {},
        supportsPhoto: false, // ATS discourages photos
    };
}

// ============================================================================
// PRESET REGISTRY
// ============================================================================

type PresetComputer = (
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions
) => PresetResult;

const PRESET_COMPUTERS: Record<PresetId, PresetComputer> = {
    SIDEBAR: computeSidebarFrames,
    TOP_HEADER: computeTopHeaderFrames,
    SPLIT_HEADER: computeSplitHeaderFrames,
    LEFT_RAIL: computeLeftRailFrames,
    DUAL_SIDEBAR: computeDualSidebarFrames,
    ATS_ONE_COLUMN: computeAtsOneColumnFrames,
};

/**
 * Compute layout frames for a given preset.
 */
export function computePresetFrames(
    presetId: PresetId,
    paper: { width: number; height: number },
    margins: { top: number; right: number; bottom: number; left: number },
    options: PresetOptions = {}
): PresetResult {
    const computer = PRESET_COMPUTERS[presetId];
    if (!computer) {
        console.warn(`[NEXAL2] Unknown preset: ${presetId}, falling back to SIDEBAR`);
        return PRESET_COMPUTERS.SIDEBAR(paper, margins, options);
    }
    return computer(paper, margins, options);
}

/**
 * Get all available preset IDs in logical cycle order.
 */
export function getPresetIds(): PresetId[] {
    return [
        'SIDEBAR',
        'TOP_HEADER',
        'SPLIT_HEADER',
        'LEFT_RAIL',
        'DUAL_SIDEBAR',
        'ATS_ONE_COLUMN',
    ];
}

export default PRESET_COMPUTERS;
</file>

<file path="constraints/regions.ts">
/**
 * NEXAL2 - Region Profiles
 * 
 * Defines region-specific CV conventions: paper format, margins, photo policy.
 * Region determines the base constraints before presets are applied.
 */

// ============================================================================
// TYPES
// ============================================================================

export type RegionId = 'FR' | 'CH_DE' | 'CH_FR' | 'DE' | 'US' | 'UK';

export type PhotoPolicy = 'required' | 'recommended' | 'optional' | 'discouraged';

export type Density = 'compact' | 'normal' | 'airy';

export interface RegionProfile {
    id: RegionId;
    name: string;
    paperFormat: 'A4' | 'LETTER';
    margins: {
        top: number;    // pt
        right: number;
        bottom: number;
        left: number;
    };
    photoPolicy: PhotoPolicy;
    density: Density;
    atsDefault: boolean;  // Whether ATS-friendly format is recommended
    notes?: string;
}

// ============================================================================
// REGION DEFINITIONS
// ============================================================================

export const REGIONS: Record<RegionId, RegionProfile> = {
    FR: {
        id: 'FR',
        name: 'France',
        paperFormat: 'A4',
        margins: { top: 40, right: 30, bottom: 40, left: 30 },
        photoPolicy: 'recommended',
        density: 'normal',
        atsDefault: false,
        notes: 'Photo expected. 1-2 pages max.',
    },
    CH_DE: {
        id: 'CH_DE',
        name: 'Suisse Allemande',
        paperFormat: 'A4',
        margins: { top: 40, right: 30, bottom: 40, left: 30 },
        photoPolicy: 'recommended',
        density: 'normal',
        atsDefault: false,
        notes: 'Photo expected. Detailed experience.',
    },
    CH_FR: {
        id: 'CH_FR',
        name: 'Suisse Romande',
        paperFormat: 'A4',
        margins: { top: 40, right: 30, bottom: 40, left: 30 },
        photoPolicy: 'recommended',
        density: 'normal',
        atsDefault: false,
        notes: 'Similar to France.',
    },
    DE: {
        id: 'DE',
        name: 'Deutschland',
        paperFormat: 'A4',
        margins: { top: 40, right: 30, bottom: 40, left: 30 },
        photoPolicy: 'recommended',
        density: 'compact',  // German CVs often dense
        atsDefault: false,
        notes: 'Photo expected. Detailed.',
    },
    US: {
        id: 'US',
        name: 'United States',
        paperFormat: 'LETTER',
        margins: { top: 50, right: 50, bottom: 50, left: 50 },
        photoPolicy: 'discouraged',
        density: 'normal',
        atsDefault: true,  // ATS is dominant in US
        notes: 'NO photo. 1 page preferred. ATS-friendly.',
    },
    UK: {
        id: 'UK',
        name: 'United Kingdom',
        paperFormat: 'A4',
        margins: { top: 40, right: 40, bottom: 40, left: 40 },
        photoPolicy: 'optional',
        density: 'normal',
        atsDefault: true,
        notes: 'Photo rare. ATS common.',
    },
};

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Get region profile by ID. Defaults to FR if unknown.
 */
export function getRegion(id: RegionId | string): RegionProfile {
    return REGIONS[id as RegionId] || REGIONS.FR;
}

/**
 * Get all available region IDs.
 */
export function getRegionIds(): RegionId[] {
    return Object.keys(REGIONS) as RegionId[];
}

export default REGIONS;
</file>

<file path="dev/GoldenProfiles.ts">
/**
 * NEXAL2 - Golden Profiles for CI Regression Testing
 * 
 * Phase 5.0: Production-grade regression test suite.
 * 
 * These profiles represent real-world edge cases and typical CVs.
 * They are deterministic and cover:
 * - Classic 1-page CV
 * - Multi-page CV (2-3 pages)
 * - No experiences (student CV)
 * - No education
 * - Long titles/company names
 * - Very long bullet points
 * - Many skills (50+)
 * - Many languages (10+)
 * - Mixed empty fields
 * - Different date formats
 * - Extreme oversized block
 * - ATS-friendly minimal CV
 */

export interface GoldenProfile {
    name: string;
    description: string;
    data: any;
}

// ============================================================================
// GOLDEN PROFILES
// ============================================================================

export const GOLDEN_PROFILES: GoldenProfile[] = [
    // 1. Classic 1-page CV
    {
        name: 'GOLDEN_01_CLASSIC',
        description: 'Classic 1-page CV with short content',
        data: {
            id: 'golden-01',
            personal: {
                firstName: 'Pierre',
                lastName: 'Martin',
                title: 'Software Developer',
                contact: { email: 'pierre.martin@example.com', phone: '+33 6 12 34 56 78' },
                address: 'Paris, France',
                summary: 'DÃ©veloppeur logiciel avec 3 ans d\'expÃ©rience.',
            },
            experiences: [
                {
                    company: 'TechCorp',
                    role: 'Junior Developer',
                    startDate: '2021-01',
                    endDate: 'Present',
                    tasks: ['DÃ©veloppement d\'applications web', 'Maintenance de code existant'],
                },
            ],
            educations: [
                { school: 'UniversitÃ© Paris-Saclay', degree: 'Master Informatique', year: '2020' },
            ],
            skills: ['JavaScript', 'React', 'Node.js', 'Python'],
            languages: [{ name: 'FranÃ§ais', level: 'Natif' }, { name: 'Anglais', level: 'Courant' }],
        },
    },

    // 2. Multi-page CV (2-3 pages)
    {
        name: 'GOLDEN_02_MULTIPAGE',
        description: 'Multi-page CV with extensive experience (2-3 pages)',
        data: {
            id: 'golden-02',
            personal: {
                firstName: 'Marie',
                lastName: 'Dubois',
                title: 'Senior Engineering Manager',
                contact: { email: 'marie.dubois@example.com', phone: '+41 79 123 45 67' },
                address: 'GenÃ¨ve, Suisse',
                summary: 'Engineering manager avec 15 ans d\'expÃ©rience dans le dÃ©veloppement logiciel et la gestion d\'Ã©quipes techniques internationales.',
            },
            experiences: [
                {
                    company: 'BigTech AG', role: 'Engineering Manager', startDate: '2019-01', endDate: 'Present',
                    tasks: ['Direction d\'une Ã©quipe de 20 ingÃ©nieurs', 'DÃ©finition de la roadmap technique', 'Recrutement et mentorat', 'Mise en place des processus agiles'],
                },
                {
                    company: 'StartupFlow', role: 'Tech Lead', startDate: '2015-06', endDate: '2018-12',
                    tasks: ['Architecture microservices', 'Migration cloud AWS', 'Mise en place CI/CD', 'Revues de code'],
                },
                {
                    company: 'DevStudio', role: 'Senior Developer', startDate: '2012-03', endDate: '2015-05',
                    tasks: ['DÃ©veloppement full-stack', 'Optimisation des performances', 'Formation des juniors'],
                },
                {
                    company: 'WebAgency', role: 'Developer', startDate: '2009-09', endDate: '2012-02',
                    tasks: ['DÃ©veloppement de sites web', 'IntÃ©gration CMS', 'Support client'],
                },
                {
                    company: 'ITConsult', role: 'Junior Developer', startDate: '2007-01', endDate: '2009-08',
                    tasks: ['DÃ©veloppement PHP', 'Maintenance de bases de donnÃ©es', 'Documentation technique'],
                },
            ],
            educations: [
                { school: 'EPFL', degree: 'Master en Informatique', year: '2006' },
                { school: 'UniversitÃ© de GenÃ¨ve', degree: 'Bachelor en Informatique', year: '2004' },
                { school: 'AWS', degree: 'Solutions Architect Professional', year: '2020' },
            ],
            skills: ['TypeScript', 'JavaScript', 'React', 'Node.js', 'Python', 'Go', 'Kubernetes', 'Docker', 'AWS', 'GCP', 'Terraform', 'CI/CD', 'Agile', 'Scrum', 'Leadership', 'Architecture'],
            languages: [
                { name: 'FranÃ§ais', level: 'Natif' },
                { name: 'Anglais', level: 'Courant (C1)' },
                { name: 'Allemand', level: 'IntermÃ©diaire (B1)' },
            ],
        },
    },

    // 3. No experiences (student CV)
    {
        name: 'GOLDEN_03_STUDENT',
        description: 'Student CV with no professional experience',
        data: {
            id: 'golden-03',
            personal: {
                firstName: 'Lucas',
                lastName: 'Petit',
                title: 'Ã‰tudiant en Informatique',
                contact: { email: 'lucas.petit@student.edu', phone: '+33 7 00 00 00 00' },
                address: 'Lyon, France',
                summary: 'Ã‰tudiant motivÃ© en derniÃ¨re annÃ©e d\'Ã©cole d\'ingÃ©nieur, Ã  la recherche d\'un stage de fin d\'Ã©tudes.',
            },
            experiences: [],
            educations: [
                { school: 'INSA Lyon', degree: 'DiplÃ´me d\'IngÃ©nieur Informatique (en cours)', year: '2024' },
                { school: 'LycÃ©e du Parc', degree: 'BaccalaurÃ©at S mention TrÃ¨s Bien', year: '2019' },
            ],
            skills: ['Java', 'Python', 'SQL', 'Git', 'Linux'],
            languages: [{ name: 'FranÃ§ais', level: 'Natif' }, { name: 'Anglais', level: 'B2' }],
        },
    },

    // 4. No education
    {
        name: 'GOLDEN_04_NO_EDUCATION',
        description: 'Self-taught professional with no formal education',
        data: {
            id: 'golden-04',
            personal: {
                firstName: 'Alex',
                lastName: 'Thompson',
                title: 'Full-Stack Developer',
                contact: { email: 'alex.thompson@example.com', phone: '+1 555 123 4567' },
                address: 'Austin, TX, USA',
                summary: 'Self-taught developer with 8 years of professional experience building web applications.',
            },
            experiences: [
                {
                    company: 'TechStartup Inc', role: 'Senior Developer', startDate: '2018-03', endDate: 'Present',
                    tasks: ['Full-stack development', 'Code reviews', 'Mentoring'],
                },
                {
                    company: 'WebDev Co', role: 'Developer', startDate: '2015-01', endDate: '2018-02',
                    tasks: ['Frontend development', 'API design'],
                },
            ],
            educations: [],
            skills: ['JavaScript', 'TypeScript', 'React', 'Node.js', 'PostgreSQL', 'MongoDB'],
            languages: [{ name: 'English', level: 'Native' }],
        },
    },

    // 5. Long titles and company names
    {
        name: 'GOLDEN_05_LONG_TITLES',
        description: 'CV with very long job titles and company names (wrapping test)',
        data: {
            id: 'golden-05',
            personal: {
                firstName: 'Jean-Baptiste',
                lastName: 'Delacroix-Montmorency',
                title: 'Principal Software Engineering Manager & Technical Architecture Lead for Cloud Infrastructure',
                contact: { email: 'jb.delacroix@example.com', phone: '+33 6 98 76 54 32' },
                address: 'Neuilly-sur-Seine, ÃŽle-de-France, France',
                summary: 'Experienced technical leader specializing in distributed systems.',
            },
            experiences: [
                {
                    company: 'SociÃ©tÃ© GÃ©nÃ©rale de DÃ©veloppement Logiciel International et Solutions Cloud',
                    role: 'Directeur Adjoint des Technologies de l\'Information et de la Transformation Digitale',
                    startDate: '2020-01',
                    endDate: 'Present',
                    tasks: ['Supervision des Ã©quipes techniques internationales', 'DÃ©finition de la stratÃ©gie technologique'],
                },
            ],
            educations: [
                { school: 'Ã‰cole Polytechnique FÃ©dÃ©rale de Lausanne (EPFL)', degree: 'Doctorat en Sciences Informatiques - SpÃ©cialisation SystÃ¨mes DistribuÃ©s', year: '2015' },
            ],
            skills: ['Leadership', 'Architecture', 'Cloud'],
            languages: [{ name: 'FranÃ§ais', level: 'Natif' }],
        },
    },

    // 6. Very long bullet points
    {
        name: 'GOLDEN_06_LONG_BULLETS',
        description: 'CV with extremely long bullet points (wrapping stress test)',
        data: {
            id: 'golden-06',
            personal: {
                firstName: 'Sarah',
                lastName: 'Chen',
                title: 'Data Scientist',
                contact: { email: 'sarah.chen@example.com' },
                address: 'San Francisco, CA',
                summary: 'Data scientist specializing in ML.',
            },
            experiences: [
                {
                    company: 'DataCorp',
                    role: 'Senior Data Scientist',
                    startDate: '2020-01',
                    endDate: 'Present',
                    tasks: [
                        'Led the development and deployment of a comprehensive machine learning pipeline for real-time fraud detection, processing over 10 million transactions per day with 99.9% accuracy and reducing false positives by 45% compared to the previous rule-based system, resulting in annual savings of $2.3M.',
                        'Collaborated with cross-functional teams including product managers, software engineers, and business stakeholders to define key performance indicators and success metrics for the recommendation engine, ultimately achieving a 28% increase in user engagement.',
                        'Mentored a team of 5 junior data scientists.',
                    ],
                },
            ],
            educations: [
                { school: 'Stanford University', degree: 'PhD in Computer Science - Machine Learning', year: '2019' },
            ],
            skills: ['Python', 'TensorFlow', 'PyTorch', 'SQL', 'Spark'],
            languages: [{ name: 'English', level: 'Native' }, { name: 'Mandarin', level: 'Native' }],
        },
    },

    // 7. Many skills (50+)
    {
        name: 'GOLDEN_07_MANY_SKILLS',
        description: 'CV with 50+ skills',
        data: {
            id: 'golden-07',
            personal: {
                firstName: 'Michael',
                lastName: 'Innovator',
                title: 'Polyglot Developer',
                contact: { email: 'michael@example.com' },
                summary: 'Developer with broad technical expertise.',
            },
            experiences: [
                { company: 'TechCo', role: 'Developer', startDate: '2015-01', endDate: 'Present', tasks: ['Development'] },
            ],
            educations: [{ school: 'MIT', degree: 'BS Computer Science', year: '2014' }],
            skills: [
                'JavaScript', 'TypeScript', 'Python', 'Java', 'C++', 'C#', 'Go', 'Rust', 'Ruby', 'PHP',
                'Swift', 'Kotlin', 'Scala', 'Haskell', 'Elixir', 'Clojure', 'R', 'MATLAB', 'Julia', 'Perl',
                'React', 'Vue', 'Angular', 'Svelte', 'Next.js', 'Nuxt', 'Node.js', 'Express', 'NestJS', 'Django',
                'Flask', 'FastAPI', 'Spring', 'Rails', 'Laravel', 'ASP.NET', 'PostgreSQL', 'MySQL', 'MongoDB', 'Redis',
                'Elasticsearch', 'GraphQL', 'REST', 'gRPC', 'Docker', 'Kubernetes', 'AWS', 'GCP', 'Azure', 'Terraform',
                'Ansible', 'Jenkins', 'GitHub Actions', 'GitLab CI',
            ],
            languages: [{ name: 'English', level: 'Native' }],
        },
    },

    // 8. Many languages (10+)
    {
        name: 'GOLDEN_08_MANY_LANGUAGES',
        description: 'CV with 10+ spoken languages',
        data: {
            id: 'golden-08',
            personal: {
                firstName: 'Emma',
                lastName: 'Polyglotte',
                title: 'International Relations Specialist',
                contact: { email: 'emma.poly@example.com', phone: '+41 22 123 45 67' },
                address: 'Geneva, Switzerland',
                summary: 'Specialist in international relations with exceptional language skills.',
            },
            experiences: [
                { company: 'United Nations', role: 'Translator', startDate: '2018-01', endDate: 'Present', tasks: ['Translation', 'Interpretation'] },
            ],
            educations: [{ school: 'Geneva University', degree: 'MA Translation Studies', year: '2017' }],
            skills: ['Translation', 'Interpretation', 'Diplomacy'],
            languages: [
                { name: 'French', level: 'Native' }, { name: 'English', level: 'Native' }, { name: 'German', level: 'Fluent (C2)' },
                { name: 'Italian', level: 'Fluent (C1)' }, { name: 'Spanish', level: 'Fluent (C1)' }, { name: 'Portuguese', level: 'Advanced (B2)' },
                { name: 'Russian', level: 'Advanced (B2)' }, { name: 'Mandarin', level: 'Intermediate (B1)' }, { name: 'Arabic', level: 'Intermediate (B1)' },
                { name: 'Japanese', level: 'Basic (A2)' }, { name: 'Korean', level: 'Basic (A2)' }, { name: 'Dutch', level: 'Basic (A2)' },
            ],
        },
    },

    // 9. Mixed empty fields
    {
        name: 'GOLDEN_09_SPARSE',
        description: 'CV with many missing optional fields',
        data: {
            id: 'golden-09',
            personal: {
                firstName: 'Anonymous',
                lastName: 'User',
                title: 'Developer',
                contact: { email: 'anon@example.com' },
                // No phone, no address, no summary
            },
            experiences: [
                { company: 'Company', role: 'Role', startDate: '2020-01', tasks: [] }, // No endDate, no tasks
            ],
            educations: [], // No education
            skills: ['Skill'], // Minimal
            languages: [], // No languages
        },
    },

    // 10. Different date formats
    {
        name: 'GOLDEN_10_DATE_FORMATS',
        description: 'CV with various date formats',
        data: {
            id: 'golden-10',
            personal: {
                firstName: 'Date',
                lastName: 'Tester',
                title: 'QA Engineer',
                contact: { email: 'date@example.com' },
            },
            experiences: [
                { company: 'Current Co', role: 'QA', startDate: '2022-06', endDate: 'Present', tasks: ['Testing'] },
                { company: 'Year Only', role: 'QA', startDate: '2020', endDate: '2022', tasks: ['Testing'] },
                { company: 'Full Date', role: 'QA', startDate: '2018-01-15', endDate: '2019-12-31', tasks: ['Testing'] },
            ],
            educations: [{ school: 'University', degree: 'Degree', year: '2017' }],
            skills: ['Testing'],
            languages: [{ name: 'English', level: 'Native' }],
        },
    },

    // 11. Extreme oversized block
    {
        name: 'GOLDEN_11_OVERSIZED',
        description: 'CV with a single massive experience block that overflows',
        data: {
            id: 'golden-11',
            personal: {
                firstName: 'Overflow',
                lastName: 'Test',
                title: 'Senior Developer',
                contact: { email: 'overflow@example.com' },
            },
            experiences: [
                {
                    company: 'MegaCorp',
                    role: 'Principal Engineer',
                    startDate: '2010-01',
                    endDate: 'Present',
                    tasks: [
                        'Task 1: Long description of work done on project Alpha involving multiple systems.',
                        'Task 2: Long description of work done on project Beta involving multiple systems.',
                        'Task 3: Long description of work done on project Gamma involving multiple systems.',
                        'Task 4: Long description of work done on project Delta involving multiple systems.',
                        'Task 5: Long description of work done on project Epsilon involving multiple systems.',
                        'Task 6: Long description of work done on project Zeta involving multiple systems.',
                        'Task 7: Long description of work done on project Eta involving multiple systems.',
                        'Task 8: Long description of work done on project Theta involving multiple systems.',
                        'Task 9: Long description of work done on project Iota involving multiple systems.',
                        'Task 10: Long description of work done on project Kappa involving multiple systems.',
                        'Task 11: Long description of work done on project Lambda involving multiple systems.',
                        'Task 12: Long description of work done on project Mu involving multiple systems.',
                        'Task 13: Long description of work done on project Nu involving multiple systems.',
                        'Task 14: Long description of work done on project Xi involving multiple systems.',
                        'Task 15: Long description of work done on project Omicron involving multiple systems.',
                    ],
                },
            ],
            educations: [{ school: 'University', degree: 'BS', year: '2009' }],
            skills: ['Everything'],
            languages: [{ name: 'English', level: 'Native' }],
        },
    },

    // 12. ATS-friendly minimal CV
    {
        name: 'GOLDEN_12_ATS_MINIMAL',
        description: 'Simple ATS-optimized CV (minimal formatting)',
        data: {
            id: 'golden-12',
            personal: {
                firstName: 'ATS',
                lastName: 'Friendly',
                title: 'Software Engineer',
                contact: { email: 'ats@example.com', phone: '+1 555 000 0000' },
                address: 'New York, NY',
                summary: 'Software engineer with 5 years experience in web development.',
            },
            experiences: [
                {
                    company: 'WebCorp', role: 'Software Engineer', startDate: '2019-01', endDate: 'Present',
                    tasks: ['Developed web applications using React and Node.js', 'Collaborated with team members'],
                },
                {
                    company: 'DevShop', role: 'Junior Developer', startDate: '2017-06', endDate: '2018-12',
                    tasks: ['Assisted in frontend development', 'Fixed bugs'],
                },
            ],
            educations: [
                { school: 'State University', degree: 'Bachelor of Science in Computer Science', year: '2017' },
            ],
            skills: ['JavaScript', 'React', 'Node.js', 'SQL', 'Git'],
            languages: [{ name: 'English', level: 'Native' }],
        },
    },
];

export default GOLDEN_PROFILES;
</file>

<file path="dev/index.ts">
/**
 * NEXAL2 - Dev Module Index
 * 
 * Development and testing utilities for NEXAL2.
 */

export {
    validateLayout,
    formatValidationResult,
    type LayoutIssue,
    type ValidationResult
} from './LayoutValidator';

export {
    runValidationMatrix,
    runAndLogMatrix,
    generateMatrixCases,
    computeEnhancedSignature,
    formatMatrixSummary,
    type MatrixCase,
    type MatrixResult,
    type MatrixSummary
} from './MatrixRunner';

export {
    runLongProfileTests,
    runAndLogLongProfileTests,
    LONG_MOCK_PROFILE,
    type LongProfileTestResult,
} from './LongProfileRunner';

// Phase 4.8: Pagination Matrix Runner
export {
    runPaginationMatrix,
    runAndLogPaginationMatrix,
    MEDIUM_MOCK_PROFILE,
    EDGECASE_MOCK_PROFILE,
    type PaginationMatrixResult,
    type PaginationMatrixSummary,
} from './PaginationMatrixRunner';

// Phase 5.0: Golden Profiles for CI testing
export {
    GOLDEN_PROFILES,
    type GoldenProfile,
} from './GoldenProfiles';

// Phase 5.0: Pagination CI Gate
export {
    runPaginationCIGate,
    generateSnapshotData,
    type SnapshotFile,
    type SnapshotCase,
    type TestResult,
    type TestSummary,
    REGIONS as CI_REGIONS,
    PRESETS as CI_PRESETS,
} from './PaginationCIGate';
</file>

<file path="dev/LayoutValidator.ts">
/**
 * NEXAL2 - Layout Validator
 * 
 * Automated validation of layout results to detect regressions.
 * Checks for negative frames, out-of-bounds, overflow, gaps, NaN values.
 * 
 * Phase 4.3: Regression harness.
 */

import type { LayoutTree, LayoutNode, LayoutConstraints } from '../types';

// ============================================================================
// TYPES
// ============================================================================

export type IssueLevel = 'error' | 'warn';

export interface LayoutIssue {
    level: IssueLevel;
    code: string;
    nodeId?: string;
    nodeType?: string;
    message: string;
    data?: Record<string, unknown>;
}

export interface ValidationResult {
    valid: boolean;
    issues: LayoutIssue[];
    stats: {
        totalNodes: number;
        checkedNodes: number;
        errors: number;
        warnings: number;
    };
}

// ============================================================================
// CONSTANTS
// ============================================================================

// Tolerance for floating point comparisons (in points)
const EPS_PT = 0.5;

// ============================================================================
// MAIN VALIDATOR
// ============================================================================

/**
 * Validate a LayoutTree for common issues.
 * 
 * @param layout - The layout tree to validate
 * @param constraints - Optional constraints for context-aware validation
 * @returns Array of issues found
 */
export function validateLayout(
    layout: LayoutTree,
    constraints?: LayoutConstraints
): ValidationResult {
    const issues: LayoutIssue[] = [];

    // Phase 4.6: Use paper dimensions from constraints (per-page), not layout.bounds (total)
    const paperFromConstraints = (constraints as any)?.paper;
    const paperWidth = paperFromConstraints?.width ?? layout.bounds.width;
    // Per-page height (not total height which includes all pages)
    const paperHeightPerPage = paperFromConstraints?.height ??
        (layout.pages.length > 0 ? layout.pages[0].frame.height : layout.bounds.height);

    // Get margins from constraints if available
    const margins = (constraints as any)?.margins || { top: 0, right: 0, bottom: 0, left: 0 };
    const frames = (constraints as any)?.frames;
    const presetId = (constraints as any)?.presetId;
    const sidebarPosition = (constraints as any)?.sidebarPosition;

    let totalNodes = 0;
    let checkedNodes = 0;

    /**
     * Walk all nodes with accumulated parent offset.
     * Phase 4.4: parentOffsetX/Y allows checking relative children in absolute space.
     */
    function walkNode(
        node: LayoutNode,
        depth: number = 0,
        parentOffsetX: number = 0,
        parentOffsetY: number = 0
    ): void {
        totalNodes++;
        checkedNodes++;

        const { frame, nodeId, nodeType, children } = node;

        // Compute absolute position (for bounds checking)
        const absX = parentOffsetX + frame.x;
        const absY = parentOffsetY + frame.y;
        const absRightEdge = absX + frame.width;
        const absBottomEdge = absY + frame.height;

        // Check: NaN_FRAME
        if (!Number.isFinite(frame.x) || !Number.isFinite(frame.y) ||
            !Number.isFinite(frame.width) || !Number.isFinite(frame.height)) {
            issues.push({
                level: 'error',
                code: 'NAN_FRAME',
                nodeId,
                nodeType,
                message: `Frame contains NaN/Infinity`,
                data: { frame }
            });
        }

        // Check: NEGATIVE_FRAME
        if (frame.width <= 0) {
            issues.push({
                level: 'error',
                code: 'NEGATIVE_FRAME',
                nodeId,
                nodeType,
                message: `Negative or zero width: ${frame.width.toFixed(2)}pt`,
                data: { width: frame.width }
            });
        }
        if (frame.height <= 0) {
            issues.push({
                level: 'error',
                code: 'NEGATIVE_FRAME',
                nodeId,
                nodeType,
                message: `Negative or zero height: ${frame.height.toFixed(2)}pt`,
                data: { height: frame.height }
            });
        }

        // Check: OUT_OF_BOUNDS (using absolute positions)
        // Only check top-level containers (depth <= 1) to avoid false positives from relative children
        if (depth <= 1) {
            if (absX < -EPS_PT) {
                issues.push({
                    level: 'warn',
                    code: 'OUT_OF_BOUNDS',
                    nodeId,
                    nodeType,
                    message: `x < 0: ${absX.toFixed(2)}pt`,
                    data: { absX }
                });
            }
            if (absY < -EPS_PT) {
                issues.push({
                    level: 'warn',
                    code: 'OUT_OF_BOUNDS',
                    nodeId,
                    nodeType,
                    message: `y < 0: ${absY.toFixed(2)}pt`,
                    data: { absY }
                });
            }

            if (absRightEdge > paperWidth + EPS_PT) {
                issues.push({
                    level: 'warn',
                    code: 'OUT_OF_BOUNDS',
                    nodeId,
                    nodeType,
                    message: `Right edge exceeds paper: ${absRightEdge.toFixed(2)}pt > ${paperWidth.toFixed(2)}pt`,
                    data: { absRightEdge, paperWidth }
                });
            }
            if (absBottomEdge > paperHeightPerPage + EPS_PT) {
                issues.push({
                    level: 'warn',
                    code: 'OUT_OF_BOUNDS',
                    nodeId,
                    nodeType,
                    message: `Bottom edge exceeds paper: ${absBottomEdge.toFixed(2)}pt > ${paperHeightPerPage.toFixed(2)}pt`,
                    data: { absBottomEdge, paperHeightPerPage }
                });
            }
        }

        // Recurse into children with accumulated offset
        children?.forEach(child => walkNode(child, depth + 1, absX, absY));
    }

    // Walk all pages (starting at depth 0, offset 0,0)
    layout.pages.forEach(page => walkNode(page, 0, 0, 0));

    // Check: OVERFLOW_MAIN (main content overflows page)
    const mainMaxY = findMaxY(layout, 'main');
    const allowedMaxY = paperHeightPerPage - margins.bottom;
    if (mainMaxY > allowedMaxY + EPS_PT) {
        issues.push({
            level: 'warn',
            code: 'OVERFLOW_MAIN',
            message: `Main content overflows: ${mainMaxY.toFixed(2)}pt > ${allowedMaxY.toFixed(2)}pt`,
            data: { mainMaxY, allowedMaxY, overflow: mainMaxY - allowedMaxY }
        });
    }

    // Check: FLUSH_GAP_SIDEBAR_RIGHT
    if (presetId === 'SIDEBAR' && sidebarPosition === 'right' && frames?.sidebar) {
        const sidebarRightEdge = frames.sidebar.x + frames.sidebar.width;
        const delta = paperWidth - sidebarRightEdge;
        if (Math.abs(delta) > EPS_PT) {
            issues.push({
                level: 'error',
                code: 'FLUSH_GAP_SIDEBAR_RIGHT',
                message: `Sidebar RIGHT does not flush to paper edge: gap=${delta.toFixed(2)}pt`,
                data: { sidebarRightEdge, paperWidth, delta }
            });
        }
    }

    // Check: FLUSH_GAP_SIDEBAR_LEFT
    if (presetId === 'SIDEBAR' && sidebarPosition === 'left' && frames?.sidebar) {
        if (frames.sidebar.x > EPS_PT) {
            issues.push({
                level: 'error',
                code: 'FLUSH_GAP_SIDEBAR_LEFT',
                message: `Sidebar LEFT does not flush to paper edge: x=${frames.sidebar.x.toFixed(2)}pt`,
                data: { sidebarX: frames.sidebar.x }
            });
        }
    }

    // Phase 4.9: Include pagination warnings from paginationMeta
    if (layout.paginationMeta?.warnings) {
        for (const warn of layout.paginationMeta.warnings) {
            issues.push({
                level: 'warn',
                code: warn.code,
                nodeId: warn.nodeId,
                nodeType: warn.nodeType,
                message: warn.message,
                data: warn.data,
            });
        }
    }

    const errors = issues.filter(i => i.level === 'error').length;
    const warnings = issues.filter(i => i.level === 'warn').length;

    return {
        valid: errors === 0,
        issues,
        stats: {
            totalNodes,
            checkedNodes,
            errors,
            warnings,
        }
    };
}

/**
 * Find the maximum absolute Y coordinate within a subtree starting from a given node ID.
 * 
 * Phase 4.7 fix: Uses parent offset accumulation (like walkNode) for accurate
 * overflow detection with relative child coordinates.
 */
function findMaxY(layout: LayoutTree, rootId: string): number {
    let maxY = 0;

    function walk(
        node: LayoutNode,
        inSubtree: boolean,
        parentOffsetX: number = 0,
        parentOffsetY: number = 0
    ): void {
        const isRoot = node.nodeId === rootId;
        const inTarget = inSubtree || isRoot;

        // Compute absolute position
        const absX = parentOffsetX + node.frame.x;
        const absY = parentOffsetY + node.frame.y;
        const absBottomEdge = absY + node.frame.height;

        if (inTarget) {
            if (absBottomEdge > maxY) maxY = absBottomEdge;
        }

        // Recurse with accumulated offset
        node.children?.forEach(child => walk(child, inTarget, absX, absY));
    }

    layout.pages.forEach(page => walk(page, false, 0, 0));
    return maxY;
}

/**
 * Format validation result for console output.
 */
export function formatValidationResult(result: ValidationResult): string {
    const lines: string[] = [];

    if (result.valid) {
        lines.push(`âœ… PASS (${result.stats.totalNodes} nodes, ${result.stats.warnings} warnings)`);
    } else {
        lines.push(`âŒ FAIL (${result.stats.errors} errors, ${result.stats.warnings} warnings)`);
    }

    // Top 5 issues
    const topIssues = result.issues.slice(0, 5);
    topIssues.forEach(issue => {
        const icon = issue.level === 'error' ? 'ðŸ”´' : 'ðŸŸ¡';
        lines.push(`  ${icon} ${issue.code}: ${issue.message}`);
    });

    if (result.issues.length > 5) {
        lines.push(`  ... and ${result.issues.length - 5} more issues`);
    }

    return lines.join('\n');
}

export default validateLayout;
</file>

<file path="dev/LongProfileRunner.ts">
/**
 * NEXAL2 - Long Profile Test Runner
 * 
 * Tests pagination with a profile that overflows multiple pages.
 * 
 * Phase 4.5: Pagination regression tests.
 */

import { createConstraints, type ChameleonConstraints } from '../constraints/createConstraints';
import { type PresetId } from '../constraints/presets';
import { buildScene } from '../scenegraph';
import { computeLayout } from '../layout';
import { validateLayout, formatValidationResult, type ValidationResult } from './LayoutValidator';

// ============================================================================
// LONG MOCK PROFILE (for pagination testing)
// ============================================================================

export const LONG_MOCK_PROFILE = {
    id: 'long-test-profile',
    personal: {
        firstName: 'Jean-Pierre',
        lastName: 'DÃ©veloppeur',
        title: 'Senior Software Engineer & Technical Architect',
        contact: {
            email: 'jp.developpeur@example.com',
            phone: '+41 79 123 45 67',
        },
        address: 'GenÃ¨ve, Suisse',
        summary: 'IngÃ©nieur logiciel expÃ©rimentÃ© avec plus de 12 ans d\'expÃ©rience dans le dÃ©veloppement d\'applications web et mobiles. Expertise en architecture microservices, cloud computing (AWS, GCP), et mÃ©thodologies agiles. PassionnÃ© par l\'innovation technologique et le mentorat d\'Ã©quipes.',
    },
    experiences: [
        {
            company: 'Tech Innovation SA',
            role: 'Lead Technical Architect',
            startDate: '2020-01',
            endDate: 'Present',
            tasks: [
                'Conception et mise en Å“uvre d\'une architecture microservices pour une plateforme fintech, gÃ©rant plus de 10M de transactions par jour',
                'Direction technique d\'une Ã©quipe de 15 dÃ©veloppeurs rÃ©partis sur 3 continents',
                'Migration complÃ¨te de l\'infrastructure on-premise vers AWS (EKS, RDS, ElastiCache, SQS)',
                'Mise en place de pipelines CI/CD avec GitHub Actions, ArgoCD et Kubernetes',
                'RÃ©duction des coÃ»ts d\'infrastructure de 40% grÃ¢ce Ã  l\'optimisation des ressources cloud',
            ],
        },
        {
            company: 'Digital Solutions Group',
            role: 'Senior Full-Stack Developer',
            startDate: '2017-03',
            endDate: '2019-12',
            tasks: [
                'DÃ©veloppement d\'une application SaaS de gestion RH utilisÃ©e par plus de 500 entreprises',
                'ImplÃ©mentation de fonctionnalitÃ©s temps rÃ©el avec WebSockets et Redis Pub/Sub',
                'Conception et dÃ©veloppement d\'APIs RESTful conformes aux standards OpenAPI 3.0',
                'Optimisation des performances frontend avec React, Redux et techniques de lazy loading',
                'Mentorat de 3 dÃ©veloppeurs juniors et conduite de revues de code hebdomadaires',
            ],
        },
        {
            company: 'StartupBoost SÃ rl',
            role: 'Full-Stack Developer',
            startDate: '2014-06',
            endDate: '2017-02',
            tasks: [
                'DÃ©veloppement from scratch d\'une plateforme e-commerce multi-tenant',
                'IntÃ©gration de systÃ¨mes de paiement (Stripe, PayPal, Twint)',
                'Mise en place d\'un systÃ¨me de recommandation basÃ© sur le machine learning',
                'Gestion de la base de donnÃ©es PostgreSQL avec optimisation des requÃªtes complexes',
            ],
        },
        {
            company: 'WebAgency Plus',
            role: 'Junior Developer',
            startDate: '2012-01',
            endDate: '2014-05',
            tasks: [
                'DÃ©veloppement de sites web responsive pour des clients B2B',
                'Maintenance et Ã©volution d\'applications PHP/Laravel existantes',
                'CrÃ©ation de thÃ¨mes WordPress personnalisÃ©s',
            ],
        },
        {
            company: 'Consulting IT',
            role: 'Intern Developer',
            startDate: '2011-06',
            endDate: '2011-12',
            tasks: [
                'DÃ©veloppement d\'outils internes en Python',
                'Support utilisateur et documentation technique',
            ],
        },
    ],
    educations: [
        {
            school: 'Ã‰cole Polytechnique FÃ©dÃ©rale de Lausanne (EPFL)',
            degree: 'Master en Informatique - SpÃ©cialisation SystÃ¨mes DistribuÃ©s',
            year: '2011',
        },
        {
            school: 'HEIG-VD (Haute Ã‰cole d\'IngÃ©nierie)',
            degree: 'Bachelor en Informatique de Gestion',
            year: '2009',
        },
        {
            school: 'AWS',
            degree: 'Solutions Architect Professional Certification',
            year: '2021',
        },
        {
            school: 'Google Cloud',
            degree: 'Professional Cloud Architect',
            year: '2022',
        },
    ],
    skills: [
        'TypeScript', 'JavaScript', 'React', 'Node.js', 'Python', 'Go',
        'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch',
        'AWS', 'GCP', 'Kubernetes', 'Docker', 'Terraform',
        'CI/CD', 'Microservices', 'System Design', 'Agile/Scrum',
    ],
    languages: [
        { name: 'FranÃ§ais', level: 'Langue maternelle' },
        { name: 'Anglais', level: 'Courant (C1)' },
        { name: 'Allemand', level: 'IntermÃ©diaire (B1)' },
        { name: 'Espagnol', level: 'Notions (A2)' },
    ],
};

// ============================================================================
// LONG PROFILE TEST RUNNER
// ============================================================================

export interface LongProfileTestResult {
    presetId: PresetId;
    paperFormat: 'A4' | 'LETTER';
    pageCount: number;
    validation: ValidationResult;
    didPaginate: boolean;
}

/**
 * Run pagination tests with the long mock profile.
 */
export function runLongProfileTests(): LongProfileTestResult[] {
    const presets: PresetId[] = ['SIDEBAR', 'TOP_HEADER', 'ATS_ONE_COLUMN'];
    const results: LongProfileTestResult[] = [];

    for (const presetId of presets) {
        // Test with A4
        results.push(testPresetWithLongProfile(presetId, 'FR'));

        // Test with LETTER
        results.push(testPresetWithLongProfile(presetId, 'US'));
    }

    return results;
}

function testPresetWithLongProfile(
    presetId: PresetId,
    regionId: 'FR' | 'US'
): LongProfileTestResult {
    const constraints = createConstraints({
        regionId,
        presetId,
        sidebarPosition: 'left',
    });

    const design = {
        paperFormat: constraints.paperFormat,
        showPhoto: constraints.supportsPhoto,
        sidebarPosition: 'left',
        accentColor: '#2563EB',
    };

    const scene = buildScene(LONG_MOCK_PROFILE, design);
    const layout = computeLayout(scene, constraints as any);
    const validation = validateLayout(layout, constraints as any);

    return {
        presetId,
        paperFormat: constraints.paperFormat,
        pageCount: layout.pages.length,
        validation,
        didPaginate: layout.pages.length > 1,
    };
}
/**
 * Format and log long profile test results.
 * Phase 4.6: Enhanced with per-page validation logging.
 */
export function runAndLogLongProfileTests(): void {
    console.log('\n' + '='.repeat(60));
    console.log('NEXAL2 Long Profile Pagination Tests (Phase 4.6)');
    console.log('='.repeat(60));

    const results = runLongProfileTests();

    let passed = 0;
    let failed = 0;

    for (const result of results) {
        const status = result.validation.valid ? 'âœ…' : 'âŒ';
        const pagination = result.didPaginate
            ? `ðŸ“„ ${result.pageCount} pages`
            : 'ðŸ“„ 1 page';
        const nodeStats = `(${result.validation.stats.totalNodes} nodes)`;

        console.log(`${status} ${result.presetId}/${result.paperFormat}: ${pagination} ${nodeStats}`);

        if (!result.validation.valid) {
            console.log(`   ${formatValidationResult(result.validation)}`);
            failed++;
        } else {
            // Show per-page summary for multi-page layouts
            if (result.pageCount > 1) {
                console.log(`   Per-page validation: OK (y=0 local coords, paperHeightPerPage used)`);
            }
            passed++;
        }
    }

    console.log('='.repeat(60));
    console.log(`Total: ${results.length} | Passed: ${passed} | Failed: ${failed}`);
    if (failed === 0) {
        console.log('âœ… PDF parity OK');
        console.log('âœ… Validator per-page OK');
        console.log('âœ… Orphans/widows enforced');
        console.log('ðŸŽ‰ ALL PAGINATION TESTS PASSED!');
    }
    console.log('='.repeat(60) + '\n');
}

export default runLongProfileTests;
</file>

<file path="dev/MatrixRunner.ts">
/**
 * NEXAL2 - Dev Matrix Runner
 * 
 * Automated testing of all region/preset/option combinations.
 * Runs validateLayout on each combination and reports results.
 * 
 * Phase 4.3: Regression harness.
 */

import { getRegionIds, type RegionId } from '../constraints/regions';
import { getPresetIds, type PresetId } from '../constraints/presets';
import { createConstraints, type ChameleonConstraints } from '../constraints/createConstraints';
import { buildScene } from '../scenegraph';
import { computeLayout } from '../layout';
import { validateLayout, formatValidationResult, type ValidationResult } from './LayoutValidator';

// ============================================================================
// TYPES
// ============================================================================

export interface MatrixCase {
    regionId: RegionId;
    presetId: PresetId;
    sidebarPosition: 'left' | 'right' | undefined;
}

export interface MatrixResult {
    case: MatrixCase;
    constraints: ChameleonConstraints;
    validation: ValidationResult;
    signature: string;
}

export interface MatrixSummary {
    total: number;
    passed: number;
    failed: number;
    results: MatrixResult[];
    duration: number;
}

// ============================================================================
// MOCK PROFILE (minimal valid profile for testing)
// ============================================================================

const MOCK_PROFILE = {
    id: 'test-profile',
    personal: {
        firstName: 'Test',
        lastName: 'User',
        title: 'Software Engineer',
        contact: {
            email: 'test@example.com',
            phone: '+1234567890',
        },
        address: 'Test City',
    },
    experiences: [
        {
            company: 'Test Company',
            role: 'Developer',
            startDate: '2020-01',
            endDate: '2023-12',
            tasks: ['Built features', 'Fixed bugs'],
        }
    ],
    educations: [
        {
            school: 'Test University',
            degree: 'Computer Science',
            year: '2020',
        }
    ],
    skills: ['JavaScript', 'TypeScript', 'React'],
    languages: [
        { name: 'English', level: 'Native' },
        { name: 'French', level: 'Fluent' },
    ],
};

// ============================================================================
// MATRIX GENERATION
// ============================================================================

/**
 * Generate all test cases for the validation matrix.
 */
export function generateMatrixCases(): MatrixCase[] {
    const regions = getRegionIds();
    const presets = getPresetIds();
    const cases: MatrixCase[] = [];

    for (const regionId of regions) {
        for (const presetId of presets) {
            if (presetId === 'SIDEBAR') {
                // SIDEBAR preset tests both left and right positions
                cases.push({ regionId, presetId, sidebarPosition: 'left' });
                cases.push({ regionId, presetId, sidebarPosition: 'right' });
            } else {
                // Other presets don't use sidebarPosition
                cases.push({ regionId, presetId, sidebarPosition: undefined });
            }
        }
    }

    return cases;
}

// ============================================================================
// ENHANCED SIGNATURE
// ============================================================================

/**
 * Compute an enhanced layout signature that includes all layout-relevant inputs.
 */
export function computeEnhancedSignature(
    constraints: ChameleonConstraints,
    _layout: { pages: Array<{ frame: { width: number; height: number } }> }
): string {
    const parts: (string | number)[] = [
        constraints.presetId,
        constraints.regionId,
        constraints.paperFormat,
        constraints.density,
        constraints.sidebarPosition,
        Math.round(constraints.paper.width),
        Math.round(constraints.paper.height),
        constraints.tokens.fontSize.body,
        constraints.tokens.lineHeight,
    ];

    // Add frame info as strings
    if (constraints.frames.sidebar) {
        parts.push(`sb:${Math.round(constraints.frames.sidebar.x)}:${Math.round(constraints.frames.sidebar.width)}`);
    }
    if (constraints.frames.main) {
        parts.push(`m:${Math.round(constraints.frames.main.x)}:${Math.round(constraints.frames.main.width)}`);
    }

    const json = parts.join('|');
    let hash = 0;
    for (let i = 0; i < json.length; i++) {
        const char = json.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return Math.abs(hash).toString(16).toUpperCase().padStart(8, '0').slice(0, 8);
}

// ============================================================================
// MATRIX RUNNER
// ============================================================================

/**
 * Run the full validation matrix.
 */
export function runValidationMatrix(
    profile: any = MOCK_PROFILE,
    design: any = {}
): MatrixSummary {
    const startTime = performance.now();
    const cases = generateMatrixCases();
    const results: MatrixResult[] = [];

    let passed = 0;
    let failed = 0;

    for (const testCase of cases) {
        // Create constraints
        const constraints = createConstraints({
            regionId: testCase.regionId,
            presetId: testCase.presetId,
            sidebarPosition: testCase.sidebarPosition,
        });

        // Sync design with constraints
        const syncedDesign = {
            ...design,
            paperFormat: constraints.paperFormat,
            showPhoto: constraints.supportsPhoto && (design.showPhoto ?? true),
            sidebarPosition: testCase.sidebarPosition ?? 'left',
            accentColor: design.accentColor || '#2563EB',
        };

        // Build scene and compute layout
        const scene = buildScene(profile, syncedDesign);
        const layout = computeLayout(scene, constraints as any);

        // Validate
        const validation = validateLayout(layout, constraints as any);

        // Compute signature
        const signature = computeEnhancedSignature(constraints, layout);

        results.push({
            case: testCase,
            constraints,
            validation,
            signature,
        });

        if (validation.valid) {
            passed++;
        } else {
            failed++;
        }
    }

    const duration = performance.now() - startTime;

    return {
        total: cases.length,
        passed,
        failed,
        results,
        duration,
    };
}

/**
 * Format matrix summary for console output.
 */
export function formatMatrixSummary(summary: MatrixSummary): string {
    const lines: string[] = [];

    lines.push(`\n${'='.repeat(60)}`);
    lines.push(`NEXAL2 Layout Validation Matrix`);
    lines.push(`${'='.repeat(60)}`);
    lines.push(`Total: ${summary.total} | Passed: ${summary.passed} | Failed: ${summary.failed}`);
    lines.push(`Duration: ${summary.duration.toFixed(0)}ms`);
    lines.push(`${'='.repeat(60)}\n`);

    // Group by status
    const failures = summary.results.filter(r => !r.validation.valid);
    const passes = summary.results.filter(r => r.validation.valid);

    if (failures.length > 0) {
        lines.push(`\nâŒ FAILURES (${failures.length}):\n`);
        for (const result of failures) {
            const c = result.case;
            const pos = c.sidebarPosition ? `/${c.sidebarPosition}` : '';
            lines.push(`  ${c.regionId}/${c.presetId}${pos}:`);
            lines.push(`    ${formatValidationResult(result.validation).replace(/\n/g, '\n    ')}`);
        }
    }

    if (passes.length > 0 && failures.length > 0) {
        lines.push(`\nâœ… PASSES (${passes.length}):\n`);
        const passNames = passes.map(r => {
            const c = r.case;
            const pos = c.sidebarPosition ? `/${c.sidebarPosition}` : '';
            return `${c.regionId}/${c.presetId}${pos}`;
        });
        lines.push(`  ${passNames.join(', ')}`);
    }

    if (summary.failed === 0) {
        lines.push(`\nðŸŽ‰ ALL TESTS PASSED!\n`);
    }

    return lines.join('\n');
}

/**
 * Run matrix and log results to console.
 */
export function runAndLogMatrix(profile?: any, design?: any): MatrixSummary {
    console.log('[NEXAL2] Running validation matrix...');
    const summary = runValidationMatrix(profile, design);
    console.log(formatMatrixSummary(summary));
    return summary;
}

export default runValidationMatrix;
</file>

<file path="dev/PaginationCIGate.ts">
/**
 * NEXAL2 - Pagination CI Gate (Browser-compatible core)
 * 
 * Phase 5.0: CI-friendly regression gate for pagination.
 * 
 * This module provides the core test logic without Node.js dependencies.
 * The actual CLI runner is in tests/pagination-ci-gate.ts.
 */

import { createConstraints } from '../constraints/createConstraints';
import type { PresetId } from '../constraints/presets';
import type { RegionId } from '../constraints/regions';
import { buildScene } from '../scenegraph';
import { computeLayout } from '../layout';
import { validateLayout } from './LayoutValidator';
import { GOLDEN_PROFILES, type GoldenProfile } from './GoldenProfiles';

// ============================================================================
// TYPES
// ============================================================================

export interface SnapshotCase {
    pageCount: number;
    pageSignatures: string[];
    splitPoints: number[];
    warningCodes: string[];
}

export interface SnapshotFile {
    version: number;
    generatedAt: string;
    cases: Record<string, SnapshotCase>;
}

export interface TestResult {
    caseKey: string;
    regionId: RegionId;
    presetId: PresetId;
    profileName: string;
    sidebarPosition: string;
    passed: boolean;
    pageCount: number;
    pageSignatures: string[];
    splitPoints: number[];
    warningCodes: string[];
    errorCount: number;
    warningCount: number;
    signatureMismatch: boolean;
    expectedSignatures?: string[];
    validationErrors: string[];
}

export interface TestSummary {
    totalCases: number;
    passed: number;
    failed: number;
    signatureMismatches: number;
    validationErrors: number;
    warningThresholdExceeded: number;
    results: TestResult[];
    topIssues: string[];
}

// ============================================================================
// CONSTANTS
// ============================================================================

export const SNAPSHOT_VERSION = 1;

export const REGIONS: RegionId[] = ['FR', 'CH_FR', 'CH_DE', 'DE', 'UK', 'US'];
export const PRESETS: PresetId[] = ['SIDEBAR', 'TOP_HEADER', 'SPLIT_HEADER', 'LEFT_RAIL', 'DUAL_SIDEBAR', 'ATS_ONE_COLUMN'];

// ============================================================================
// CI GATE RUNNER
// ============================================================================

/**
 * Run the pagination CI gate.
 */
export function runPaginationCIGate(options: {
    existingSnapshots?: SnapshotFile | null;
    warningThreshold?: number;
    silent?: boolean;
} = {}): TestSummary {
    const { existingSnapshots = null, warningThreshold = 0, silent = false } = options;

    const log = (msg: string) => { if (!silent) console.log(msg); };

    log('\n' + '='.repeat(70));
    log('NEXAL2 Pagination CI Gate (Phase 5.0)');
    log('='.repeat(70));
    log(`Warning threshold: ${warningThreshold}`);
    log(`Golden profiles: ${GOLDEN_PROFILES.length}`);
    log('');

    // Run all test cases
    const results: TestResult[] = [];

    for (const region of REGIONS) {
        for (const preset of PRESETS) {
            for (const profile of GOLDEN_PROFILES) {
                // For SIDEBAR preset, test both left and right positions
                const positions = preset === 'SIDEBAR' ? ['left', 'right'] : ['none'];

                for (const position of positions) {
                    const result = runTestCase(
                        region,
                        preset,
                        profile,
                        position as 'left' | 'right' | 'none',
                        existingSnapshots,
                        warningThreshold
                    );
                    results.push(result);
                }
            }
        }
    }

    // Calculate summary
    const passed = results.filter(r => r.passed).length;
    const failed = results.length - passed;
    const signatureMismatches = results.filter(r => r.signatureMismatch).length;
    const validationErrorsCount = results.filter(r => r.errorCount > 0).length;
    const warningThresholdExceeded = results.filter(r => r.warningCount > warningThreshold && r.errorCount === 0).length;

    // Top issues
    const issueMap: Record<string, number> = {};
    for (const result of results) {
        for (const error of result.validationErrors) {
            const key = error.substring(0, 60);
            issueMap[key] = (issueMap[key] || 0) + 1;
        }
    }
    const topIssues = Object.entries(issueMap)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 5)
        .map(([key, count]) => `${key} (${count}x)`);

    const summary: TestSummary = {
        totalCases: results.length,
        passed,
        failed,
        signatureMismatches,
        validationErrors: validationErrorsCount,
        warningThresholdExceeded,
        results,
        topIssues,
    };

    // Log results
    if (!silent) {
        logSummary(summary);
    }

    return summary;
}

/**
 * Run a single test case.
 */
function runTestCase(
    regionId: RegionId,
    presetId: PresetId,
    profile: GoldenProfile,
    sidebarPosition: 'left' | 'right' | 'none',
    snapshots: SnapshotFile | null,
    warningThreshold: number
): TestResult {
    const caseKey = `${regionId}|${presetId}|${profile.name}|${sidebarPosition}`;

    try {
        const constraints = createConstraints({
            regionId,
            presetId,
            sidebarPosition: sidebarPosition === 'none' ? 'left' : sidebarPosition,
        });

        const design = {
            paperFormat: constraints.paperFormat,
            showPhoto: constraints.supportsPhoto,
            sidebarPosition: sidebarPosition === 'none' ? 'left' : sidebarPosition,
            accentColor: '#2563EB',
            // Phase 5.5: Explicit values for deterministic signatures
            photoScale: 2 as const,
            layoutPreset: presetId as any,
        };

        const scene = buildScene(profile.data, design);
        const layout = computeLayout(scene, constraints as any);
        const validation = validateLayout(layout, constraints as any);

        const pageSignatures = layout.paginationMeta?.pageSignatures || [];
        const splitPoints = layout.paginationMeta?.splitPoints || [];
        const warningCodes = layout.paginationMeta?.warnings?.map(w => w.code) || [];

        const errorCount = validation.issues.filter(i => i.level === 'error').length;
        const warningCount = validation.issues.filter(i => i.level === 'warn').length;
        const validationErrors = validation.issues
            .filter(i => i.level === 'error')
            .map(i => `${i.code}: ${i.message}`);

        // Check signature match
        let signatureMismatch = false;
        let expectedSignatures: string[] | undefined;

        if (snapshots && snapshots.cases[caseKey]) {
            expectedSignatures = snapshots.cases[caseKey].pageSignatures;
            signatureMismatch = JSON.stringify(pageSignatures) !== JSON.stringify(expectedSignatures);
        }

        // Determine pass/fail
        const passed =
            errorCount === 0 &&
            !signatureMismatch &&
            warningCount <= warningThreshold;

        return {
            caseKey,
            regionId,
            presetId,
            profileName: profile.name,
            sidebarPosition,
            passed,
            pageCount: layout.pages.length,
            pageSignatures,
            splitPoints,
            warningCodes,
            errorCount,
            warningCount,
            signatureMismatch,
            expectedSignatures,
            validationErrors,
        };
    } catch (error) {
        return {
            caseKey,
            regionId,
            presetId,
            profileName: profile.name,
            sidebarPosition,
            passed: false,
            pageCount: 0,
            pageSignatures: [],
            splitPoints: [],
            warningCodes: [],
            errorCount: 1,
            warningCount: 0,
            signatureMismatch: false,
            validationErrors: [error instanceof Error ? error.message : 'Unknown error'],
        };
    }
}

/**
 * Log test summary.
 */
function logSummary(summary: TestSummary): void {
    console.log('\nðŸ“Š Summary:');
    console.log(`   Total cases:          ${summary.totalCases}`);
    console.log(`   âœ… Passed:            ${summary.passed}`);
    console.log(`   âŒ Failed:            ${summary.failed}`);
    console.log(`   ðŸ”€ Signature mismatch: ${summary.signatureMismatches}`);
    console.log(`   âš ï¸ Validation errors: ${summary.validationErrors}`);
    console.log(`   ðŸ“ Warnings exceeded: ${summary.warningThresholdExceeded}`);

    if (summary.topIssues.length > 0) {
        console.log('\nðŸ” Top issues:');
        summary.topIssues.forEach((issue, i) => {
            console.log(`   ${i + 1}. ${issue}`);
        });
    }

    // Page count distribution
    const pageCounts: Record<number, number> = {};
    for (const r of summary.results) {
        pageCounts[r.pageCount] = (pageCounts[r.pageCount] || 0) + 1;
    }
    console.log('\nðŸ“„ Page count distribution:');
    Object.entries(pageCounts)
        .sort(([a], [b]) => Number(a) - Number(b))
        .forEach(([pages, count]) => {
            console.log(`   ${pages} pages: ${'â–“'.repeat(Math.min(count, 30))} ${count}`);
        });

    // Log first 10 failures in detail
    const failures = summary.results.filter(r => !r.passed).slice(0, 10);
    if (failures.length > 0) {
        console.log('\nðŸ“‹ First 10 failing cases:');
        for (const f of failures) {
            console.log(`  âŒ ${f.caseKey}`);
            if (f.signatureMismatch) {
                console.log(`     Signature mismatch: expected ${f.expectedSignatures?.join(',')} got ${f.pageSignatures.join(',')}`);
            }
            if (f.errorCount > 0) {
                console.log(`     Errors: ${f.validationErrors.slice(0, 2).join(', ')}`);
            }
        }
    }

    console.log('\n' + '='.repeat(70));
    if (summary.failed === 0) {
        console.log('ðŸŽ‰ ALL PAGINATION CI GATE TESTS PASSED!');
    } else {
        console.log(`âŒ ${summary.failed} tests failed - see details above.`);
    }
    console.log('='.repeat(70) + '\n');
}

/**
 * Generate snapshot data from results.
 */
export function generateSnapshotData(results: TestResult[]): SnapshotFile {
    const cases: Record<string, SnapshotCase> = {};
    for (const result of results) {
        cases[result.caseKey] = {
            pageCount: result.pageCount,
            pageSignatures: result.pageSignatures,
            splitPoints: result.splitPoints.map(p => Math.round(p * 10) / 10),
            warningCodes: result.warningCodes,
        };
    }

    return {
        version: SNAPSHOT_VERSION,
        generatedAt: new Date().toISOString(),
        cases,
    };
}

export default runPaginationCIGate;
</file>

<file path="dev/PaginationMatrixRunner.ts">
/**
 * NEXAL2 - Pagination Matrix Runner
 * 
 * Phase 4.8: Production-grade regression harness for pagination.
 * 
 * Tests pagination across:
 * - 6 regions (FR, CH_FR, CH_DE, DE, UK, US)
 * - All presets
 * - Multiple profile variants (LONG, MEDIUM, EDGECASE)
 * - Sidebar positions for SIDEBAR preset
 */

import { createConstraints, type ChameleonConstraints } from '../constraints/createConstraints';
import { type PresetId } from '../constraints/presets';
import { type RegionId } from '../constraints/regions';
import { buildScene } from '../scenegraph';
import { computeLayout } from '../layout';
import { validateLayout, formatValidationResult, type ValidationResult } from './LayoutValidator';
import type { PaginationWarning } from '../layout/paginateLayout';

// All preset IDs (hardcoded to avoid import issues)
const ALL_PRESET_IDS: PresetId[] = ['SIDEBAR', 'TOP_HEADER', 'SPLIT_HEADER', 'LEFT_RAIL', 'DUAL_SIDEBAR', 'ATS_ONE_COLUMN'];

// ============================================================================
// PROFILE VARIANTS
// ============================================================================

/** Long profile for multi-page testing (from Phase 4.5) */
export const LONG_MOCK_PROFILE = {
    id: 'long-test-profile',
    personal: {
        firstName: 'Jean-Pierre',
        lastName: 'DÃ©veloppeur',
        title: 'Senior Software Engineer & Technical Architect',
        contact: {
            email: 'jp.developpeur@example.com',
            phone: '+41 79 123 45 67',
        },
        address: 'GenÃ¨ve, Suisse',
        summary: 'IngÃ©nieur logiciel expÃ©rimentÃ© avec plus de 12 ans d\'expÃ©rience dans le dÃ©veloppement d\'applications web et mobiles. Expertise en architecture microservices, cloud computing (AWS, GCP), et mÃ©thodologies agiles. PassionnÃ© par l\'innovation technologique et le mentorat d\'Ã©quipes.',
    },
    experiences: [
        {
            company: 'Tech Innovation SA',
            role: 'Lead Technical Architect',
            startDate: '2020-01',
            endDate: 'Present',
            tasks: [
                'Conception et mise en Å“uvre d\'une architecture microservices pour une plateforme fintech, gÃ©rant plus de 10M de transactions par jour',
                'Direction technique d\'une Ã©quipe de 15 dÃ©veloppeurs rÃ©partis sur 3 continents',
                'Migration complÃ¨te de l\'infrastructure on-premise vers AWS (EKS, RDS, ElastiCache, SQS)',
                'Mise en place de pipelines CI/CD avec GitHub Actions, ArgoCD et Kubernetes',
                'RÃ©duction des coÃ»ts d\'infrastructure de 40% grÃ¢ce Ã  l\'optimisation des ressources cloud',
            ],
        },
        {
            company: 'Digital Solutions Group',
            role: 'Senior Full-Stack Developer',
            startDate: '2017-03',
            endDate: '2019-12',
            tasks: [
                'DÃ©veloppement d\'une application SaaS de gestion RH utilisÃ©e par plus de 500 entreprises',
                'ImplÃ©mentation de fonctionnalitÃ©s temps rÃ©el avec WebSockets et Redis Pub/Sub',
                'Conception et dÃ©veloppement d\'APIs RESTful conformes aux standards OpenAPI 3.0',
                'Optimisation des performances frontend avec React, Redux et techniques de lazy loading',
                'Mentorat de 3 dÃ©veloppeurs juniors et conduite de revues de code hebdomadaires',
            ],
        },
        {
            company: 'StartupBoost SÃ rl',
            role: 'Full-Stack Developer',
            startDate: '2014-06',
            endDate: '2017-02',
            tasks: [
                'DÃ©veloppement from scratch d\'une plateforme e-commerce multi-tenant',
                'IntÃ©gration de systÃ¨mes de paiement (Stripe, PayPal, Twint)',
                'Mise en place d\'un systÃ¨me de recommandation basÃ© sur le machine learning',
                'Gestion de la base de donnÃ©es PostgreSQL avec optimisation des requÃªtes complexes',
            ],
        },
        {
            company: 'WebAgency Plus',
            role: 'Junior Developer',
            startDate: '2012-01',
            endDate: '2014-05',
            tasks: [
                'DÃ©veloppement de sites web responsive pour des clients B2B',
                'Maintenance et Ã©volution d\'applications PHP/Laravel existantes',
                'CrÃ©ation de thÃ¨mes WordPress personnalisÃ©s',
            ],
        },
        {
            company: 'Consulting IT',
            role: 'Intern Developer',
            startDate: '2011-06',
            endDate: '2011-12',
            tasks: [
                'DÃ©veloppement d\'outils internes en Python',
                'Support utilisateur et documentation technique',
            ],
        },
    ],
    educations: [
        {
            school: 'Ã‰cole Polytechnique FÃ©dÃ©rale de Lausanne (EPFL)',
            degree: 'Master en Informatique - SpÃ©cialisation SystÃ¨mes DistribuÃ©s',
            year: '2011',
        },
        {
            school: 'HEIG-VD (Haute Ã‰cole d\'IngÃ©nierie)',
            degree: 'Bachelor en Informatique de Gestion',
            year: '2009',
        },
        {
            school: 'AWS',
            degree: 'Solutions Architect Professional Certification',
            year: '2021',
        },
        {
            school: 'Google Cloud',
            degree: 'Professional Cloud Architect',
            year: '2022',
        },
    ],
    skills: [
        'TypeScript', 'JavaScript', 'React', 'Node.js', 'Python', 'Go',
        'PostgreSQL', 'MongoDB', 'Redis', 'Elasticsearch',
        'AWS', 'GCP', 'Kubernetes', 'Docker', 'Terraform',
        'CI/CD', 'Microservices', 'System Design', 'Agile/Scrum',
    ],
    languages: [
        { name: 'FranÃ§ais', level: 'Langue maternelle' },
        { name: 'Anglais', level: 'Courant (C1)' },
        { name: 'Allemand', level: 'IntermÃ©diaire (B1)' },
        { name: 'Espagnol', level: 'Notions (A2)' },
    ],
};

/** Phase 4.8: Medium profile (1-2 pages typically) */
export const MEDIUM_MOCK_PROFILE = {
    id: 'medium-test-profile',
    personal: {
        firstName: 'Marie',
        lastName: 'Dupont',
        title: 'Product Manager',
        contact: {
            email: 'marie.dupont@example.com',
            phone: '+41 79 888 99 00',
        },
        address: 'ZÃ¼rich, Suisse',
        summary: 'Product Manager with 5 years of experience in SaaS products.',
    },
    experiences: [
        {
            company: 'TechCorp AG',
            role: 'Senior Product Manager',
            startDate: '2021-03',
            endDate: 'Present',
            tasks: [
                'Led product strategy for B2B SaaS platform with 50K users',
                'Managed cross-functional team of 8 engineers and 2 designers',
                'Increased user retention by 25% through feature improvements',
            ],
        },
        {
            company: 'StartupOne',
            role: 'Product Manager',
            startDate: '2019-01',
            endDate: '2021-02',
            tasks: [
                'Launched MVP in 6 months with agile methodology',
                'Conducted user research and A/B testing',
            ],
        },
        {
            company: 'DigitalAgency',
            role: 'Junior PM',
            startDate: '2018-01',
            endDate: '2018-12',
            tasks: [
                'Assisted in product roadmap planning',
                'Coordinated with development teams',
            ],
        },
    ],
    educations: [
        {
            school: 'ETH ZÃ¼rich',
            degree: 'Master in Management, Technology, and Economics',
            year: '2017',
        },
        {
            school: 'University of Geneva',
            degree: 'Bachelor in Business Administration',
            year: '2015',
        },
    ],
    skills: [
        'Product Strategy', 'Agile/Scrum', 'User Research', 'A/B Testing',
        'Roadmapping', 'Stakeholder Management', 'Data Analysis', 'Figma',
    ],
    languages: [
        { name: 'French', level: 'Native' },
        { name: 'German', level: 'Fluent' },
        { name: 'English', level: 'Fluent' },
    ],
};

/** Phase 4.8: Edge case profile (stress tests) */
export const EDGECASE_MOCK_PROFILE = {
    id: 'edgecase-test-profile',
    personal: {
        firstName: 'Test',
        lastName: 'Edgecase',
        title: 'Senior Software Engineer Specialized in Distributed Systems and Cloud Architecture with Extensive Experience in Multiple Programming Languages and Frameworks Including but Not Limited to TypeScript, JavaScript, Python, Go, Rust, and C++',
        contact: {
            email: 'test@example.com',
            phone: '+1 555 123 4567',
        },
        address: 'San Francisco, CA, USA',
        summary: 'This is an intentionally very long summary to test text wrapping and overflow handling. It contains multiple sentences describing experience and skills. The goal is to ensure the layout engine can handle unusually long content without breaking. Additional padding text to make it even longer and test the limits of the layout algorithm.',
    },
    experiences: [
        {
            company: 'MegaCorp International Inc. with a Very Long Company Name to Test Wrapping',
            role: 'Principal Engineer and Technical Lead for Cloud Infrastructure',
            startDate: '2020-01',
            endDate: 'Present',
            tasks: [
                'This is an extremely long task description that spans multiple lines to test how the layout engine handles wrapping and pagination for individual list items. It should wrap correctly within the available width and not overflow.',
                'Another very long bullet point that contains technical details about implementing complex distributed systems using microservices architecture with Kubernetes, Docker, and various cloud providers including AWS, GCP, and Azure with multi-region deployment strategies.',
                'Short task 1',
                'Short task 2',
                'Short task 3',
                'Short task 4',
                'Short task 5',
                'Short task 6',
                'Short task 7',
                'Short task 8',
                'Short task 9',
                'Short task 10',
            ],
        },
    ],
    educations: [
        {
            school: 'Stanford University',
            degree: 'PhD in Computer Science',
            year: '2019',
        },
    ],
    skills: ['TypeScript'],
    languages: [{ name: 'English', level: 'Native' }],
};

// ============================================================================
// TYPES
// ============================================================================

export interface PaginationMatrixResult {
    regionId: RegionId;
    presetId: PresetId;
    profileName: string;
    sidebarPosition?: 'left' | 'right';
    paperFormat: 'A4' | 'LETTER';
    pageCount: number;
    validation: ValidationResult;
    passed: boolean;
    warningCount: number;
    /** Phase 4.9: Per-page parity signatures */
    pageSignatures: string[];
}

export interface PaginationMatrixSummary {
    totalCases: number;
    passed: number;
    failed: number;
    results: PaginationMatrixResult[];
    pageCountDistribution: Record<number, number>;
    topIssues: string[];
}

// ============================================================================
// MATRIX RUNNER
// ============================================================================

/**
 * Run pagination matrix across all combinations.
 */
export function runPaginationMatrix(): PaginationMatrixSummary {
    const results: PaginationMatrixResult[] = [];
    const regionIds: RegionId[] = ['FR', 'CH_FR', 'CH_DE', 'DE', 'UK', 'US'];
    const presetIds = ALL_PRESET_IDS;
    const profiles = [
        { name: 'LONG', data: LONG_MOCK_PROFILE },
        { name: 'MEDIUM', data: MEDIUM_MOCK_PROFILE },
        { name: 'EDGECASE', data: EDGECASE_MOCK_PROFILE },
    ];

    for (const regionId of regionIds) {
        for (const presetId of presetIds) {
            for (const profile of profiles) {
                // For SIDEBAR preset, test both left and right positions
                if (presetId === 'SIDEBAR') {
                    results.push(testCase(regionId, presetId, profile.name, profile.data, 'left'));
                    results.push(testCase(regionId, presetId, profile.name, profile.data, 'right'));
                } else {
                    results.push(testCase(regionId, presetId, profile.name, profile.data));
                }
            }
        }
    }

    // Calculate summary
    const passed = results.filter(r => r.passed).length;
    const failed = results.length - passed;

    // Page count distribution
    const pageCountDistribution: Record<number, number> = {};
    for (const result of results) {
        pageCountDistribution[result.pageCount] = (pageCountDistribution[result.pageCount] || 0) + 1;
    }

    // Top issues
    const issueMap: Record<string, number> = {};
    for (const result of results) {
        if (!result.validation.valid) {
            for (const issue of result.validation.issues) {
                const key = `${issue.code}: ${issue.message.substring(0, 50)}`;
                issueMap[key] = (issueMap[key] || 0) + 1;
            }
        }
    }
    const topIssues = Object.entries(issueMap)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 5)
        .map(([key, count]) => `${key} (${count}x)`);

    return {
        totalCases: results.length,
        passed,
        failed,
        results,
        pageCountDistribution,
        topIssues,
    };
}

/**
 * Test a single case.
 */
function testCase(
    regionId: RegionId,
    presetId: PresetId,
    profileName: string,
    profileData: any,
    sidebarPosition?: 'left' | 'right'
): PaginationMatrixResult {
    const constraints = createConstraints({
        regionId,
        presetId,
        sidebarPosition: sidebarPosition || 'left',
    });

    const design = {
        paperFormat: constraints.paperFormat,
        showPhoto: constraints.supportsPhoto,
        sidebarPosition: sidebarPosition || 'left',
        accentColor: '#2563EB',
    };

    try {
        const scene = buildScene(profileData, design);
        const layout = computeLayout(scene, constraints as any);
        const validation = validateLayout(layout, constraints as any);

        return {
            regionId,
            presetId,
            profileName,
            sidebarPosition,
            paperFormat: constraints.paperFormat,
            pageCount: layout.pages.length,
            validation,
            passed: validation.valid,
            warningCount: validation.issues.filter(i => i.level === 'warn').length,
            pageSignatures: layout.paginationMeta?.pageSignatures || [],
        };
    } catch (error) {
        return {
            regionId,
            presetId,
            profileName,
            sidebarPosition,
            paperFormat: constraints.paperFormat,
            pageCount: 0,
            validation: {
                valid: false,
                issues: [{
                    level: 'error',
                    code: 'EXCEPTION',
                    message: error instanceof Error ? error.message : 'Unknown error',
                }],
                stats: { totalNodes: 0, checkedNodes: 0, errors: 1, warnings: 0 },
            },
            passed: false,
            warningCount: 0,
            pageSignatures: [],
        };
    }
}

/**
 * Run and log pagination matrix results.
 */
export function runAndLogPaginationMatrix(): void {
    console.log('\n' + '='.repeat(70));
    console.log('NEXAL2 Pagination Matrix (Phase 4.8)');
    console.log('='.repeat(70));

    const summary = runPaginationMatrix();

    // Log results by profile
    const byProfile: Record<string, PaginationMatrixResult[]> = {};
    for (const result of summary.results) {
        if (!byProfile[result.profileName]) {
            byProfile[result.profileName] = [];
        }
        byProfile[result.profileName].push(result);
    }

    for (const [profileName, results] of Object.entries(byProfile)) {
        console.log(`\nðŸ“‹ Profile: ${profileName}`);
        console.log('-'.repeat(50));

        const profilePassed = results.filter(r => r.passed).length;
        const profileFailed = results.length - profilePassed;

        // Group by page count
        const byPages: Record<number, number> = {};
        for (const r of results) {
            byPages[r.pageCount] = (byPages[r.pageCount] || 0) + 1;
        }

        console.log(`  âœ… Passed: ${profilePassed} | âŒ Failed: ${profileFailed}`);
        console.log(`  ðŸ“„ Page distribution: ${Object.entries(byPages).map(([p, c]) => `${p}pg=${c}`).join(', ')}`);

        // Show first few failures
        const failures = results.filter(r => !r.passed).slice(0, 3);
        if (failures.length > 0) {
            console.log('  First failures:');
            for (const f of failures) {
                console.log(`    - ${f.regionId}/${f.presetId}: ${f.validation.issues[0]?.message}`);
            }
        }
    }

    // Summary
    console.log('\n' + '='.repeat(70));
    console.log(`TOTAL: ${summary.totalCases} cases | âœ… ${summary.passed} passed | âŒ ${summary.failed} failed`);

    if (summary.topIssues.length > 0) {
        console.log('\nTop Issues:');
        summary.topIssues.forEach((issue, i) => {
            console.log(`  ${i + 1}. ${issue}`);
        });
    }

    console.log('\nPage Count Distribution:');
    Object.entries(summary.pageCountDistribution)
        .sort(([a], [b]) => Number(a) - Number(b))
        .forEach(([pages, count]) => {
            console.log(`  ${pages} pages: ${'â–“'.repeat(Math.min(count, 40))} ${count}`);
        });

    if (summary.failed === 0) {
        console.log('\nðŸŽ‰ ALL PAGINATION MATRIX TESTS PASSED!');
    } else {
        console.log(`\nâš ï¸ ${summary.failed} tests failed - review issues above.`);
    }
    console.log('='.repeat(70) + '\n');
}

export default runPaginationMatrix;
</file>

<file path="editing/applyFieldPatch.ts">
/**
 * Phase 7.0 - Apply Field Patch
 * 
 * Translation layer between fieldPath and store update.
 * Handles special cases like personal.fullName.
 */

import { getValueByPath } from '../../domain/cv/v2/path-utils';
import type { CVProfile } from '../../domain/cv/v2/types';

// ============================================================================
// DISABLED FIELDS (composite displays, no inline edit)
// ============================================================================

const DISABLED_FIELD_PATHS = new Set([
    'personal.contact', // Composite: "email â€¢ phone â€¢ city"
]);

/**
 * Check if a fieldPath is editable
 */
export function isFieldEditable(fieldPath: string | undefined): boolean {
    if (!fieldPath) return false;
    return !DISABLED_FIELD_PATHS.has(fieldPath);
}

// ============================================================================
// GET VALUE BY FIELD PATH (for prefilling editor)
// ============================================================================

/**
 * Get the current value for a fieldPath from profile.
 * Handles special case: personal.fullName â†’ compose from firstName + lastName
 */
export function getFieldValue(profile: CVProfile, fieldPath: string): string {
    // Special case: fullName
    if (fieldPath === 'personal.fullName') {
        const firstName = getValueByPath<string>(profile, 'personal.firstName') || '';
        const lastName = getValueByPath<string>(profile, 'personal.lastName') || '';
        return `${firstName} ${lastName}`.trim();
    }

    // Default: direct path lookup
    const value = getValueByPath(profile, fieldPath);

    // Handle object-type values (e.g., languages[0] which is {name, level})
    if (value && typeof value === 'object') {
        // For language objects, return name
        if ('name' in value) return value.name as string;
        // Fallback: stringify
        return JSON.stringify(value);
    }

    return value !== undefined && value !== null ? String(value) : '';
}

// ============================================================================
// APPLY FIELD PATCH (update store from fieldPath + value)
// ============================================================================

interface StoreActions {
    updateField: (path: string, value: any) => void;
    batchUpdate?: (updates: Record<string, any>) => void;
}

/**
 * Apply a field patch to the store.
 * 
 * @param store - The store actions object
 * @param fieldPath - The fieldPath from the node
 * @param value - The new value (string from input)
 */
export function applyFieldPatch(
    store: StoreActions,
    fieldPath: string,
    value: string
): void {
    // Validate
    if (!isFieldEditable(fieldPath)) {
        console.warn(`[applyFieldPatch] Field "${fieldPath}" is not editable`);
        return;
    }

    // Special case: personal.fullName â†’ split into firstName + lastName
    if (fieldPath === 'personal.fullName') {
        const trimmed = value.trim();
        const spaceIndex = trimmed.indexOf(' ');

        if (spaceIndex === -1) {
            // No space: all firstName, empty lastName
            store.updateField('personal.firstName', trimmed);
            store.updateField('personal.lastName', '');
        } else {
            // Split on first space
            const firstName = trimmed.substring(0, spaceIndex);
            const lastName = trimmed.substring(spaceIndex + 1);
            store.updateField('personal.firstName', firstName);
            store.updateField('personal.lastName', lastName);
        }
        return;
    }

    // Handle skills array: skills[i] might be string or object
    // If the path is skills[N] but the current value is an object, update skills[N].name
    // This is handled automatically by lodash set

    // Default: direct update
    store.updateField(fieldPath, value);
}

export default applyFieldPatch;
</file>

<file path="editing/index.ts">
/**
 * Phase 7.0 - NEXAL2 Editing Module
 * 
 * Inline editing support for NEXAL2 renderer.
 */

export { applyFieldPatch, getFieldValue, isFieldEditable } from './applyFieldPatch';
export { InlineEditOverlay } from './InlineEditOverlay';
export type { InlineEditOverlayProps } from './InlineEditOverlay';
</file>

<file path="editing/InlineEditOverlay.tsx">
/**
 * Phase 7.0 - Inline Edit Overlay
 * 
 * Floating popover editor for inline field editing.
 * Appears near the clicked element.
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';

export interface InlineEditOverlayProps {
    isOpen: boolean;
    fieldPath: string;
    nodeId: string;
    initialValue: string;
    position: { top: number; left: number };
    onSave: (fieldPath: string, value: string) => void;
    onCancel: () => void;
}

/**
 * Floating popover editor for inline field editing.
 */
export const InlineEditOverlay: React.FC<InlineEditOverlayProps> = ({
    isOpen,
    fieldPath,
    nodeId,
    initialValue,
    position,
    onSave,
    onCancel,
}) => {
    const [value, setValue] = useState(initialValue);
    const inputRef = useRef<HTMLInputElement>(null);
    const overlayRef = useRef<HTMLDivElement>(null);

    // Focus input when opening
    useEffect(() => {
        if (isOpen && inputRef.current) {
            inputRef.current.focus();
            inputRef.current.select();
        }
    }, [isOpen]);

    // Reset value when initialValue changes
    useEffect(() => {
        setValue(initialValue);
    }, [initialValue]);

    // Handle keyboard events
    const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            onSave(fieldPath, value);
        } else if (e.key === 'Escape') {
            e.preventDefault();
            onCancel();
        }
    }, [fieldPath, value, onSave, onCancel]);

    // Handle click outside
    useEffect(() => {
        if (!isOpen) return;

        const handleClickOutside = (e: MouseEvent) => {
            if (overlayRef.current && !overlayRef.current.contains(e.target as Node)) {
                onCancel();
            }
        };

        // Delay to avoid immediate close
        const timer = setTimeout(() => {
            document.addEventListener('mousedown', handleClickOutside);
        }, 100);

        return () => {
            clearTimeout(timer);
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isOpen, onCancel]);

    if (!isOpen) return null;

    // Determine if this is a multi-line field (summary, tasks)
    const isMultiline = fieldPath === 'summary' || fieldPath.includes('tasks');

    return (
        <div
            ref={overlayRef}
            style={{
                position: 'fixed',
                top: position.top,
                left: position.left,
                zIndex: 10000,
                backgroundColor: 'white',
                borderRadius: '8px',
                boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',
                padding: '12px',
                minWidth: '280px',
                maxWidth: '400px',
            }}
        >
            {/* Header */}
            <div style={{
                fontSize: '11px',
                color: '#6B7280',
                marginBottom: '8px',
                fontFamily: 'system-ui, -apple-system, sans-serif',
            }}>
                Editing: <code style={{
                    backgroundColor: '#F3F4F6',
                    padding: '2px 4px',
                    borderRadius: '3px',
                    fontSize: '10px',
                }}>{fieldPath}</code>
            </div>

            {/* Input */}
            {isMultiline ? (
                <textarea
                    ref={inputRef as any}
                    value={value}
                    onChange={(e) => setValue(e.target.value)}
                    onKeyDown={(e) => {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            onCancel();
                        }
                    }}
                    style={{
                        width: '100%',
                        minHeight: '80px',
                        padding: '8px 10px',
                        border: '2px solid #3B82F6',
                        borderRadius: '6px',
                        fontSize: '13px',
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                        resize: 'vertical',
                        outline: 'none',
                    }}
                />
            ) : (
                <input
                    ref={inputRef}
                    type="text"
                    value={value}
                    onChange={(e) => setValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    style={{
                        width: '100%',
                        padding: '8px 10px',
                        border: '2px solid #3B82F6',
                        borderRadius: '6px',
                        fontSize: '13px',
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                        outline: 'none',
                    }}
                />
            )}

            {/* Actions */}
            <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: '8px',
                marginTop: '10px'
            }}>
                <button
                    onClick={onCancel}
                    style={{
                        padding: '6px 12px',
                        backgroundColor: '#F3F4F6',
                        border: 'none',
                        borderRadius: '5px',
                        fontSize: '12px',
                        cursor: 'pointer',
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                    }}
                >
                    Cancel <span style={{ color: '#9CA3AF', fontSize: '10px' }}>(Esc)</span>
                </button>
                <button
                    onClick={() => onSave(fieldPath, value)}
                    style={{
                        padding: '6px 12px',
                        backgroundColor: '#3B82F6',
                        color: 'white',
                        border: 'none',
                        borderRadius: '5px',
                        fontSize: '12px',
                        cursor: 'pointer',
                        fontFamily: 'system-ui, -apple-system, sans-serif',
                    }}
                >
                    Save <span style={{ color: '#93C5FD', fontSize: '10px' }}>(Enter)</span>
                </button>
            </div>
        </div>
    );
};

export default InlineEditOverlay;
</file>

<file path="hooks/index.ts">
/**
 * NEXAL2 Hooks Index
 */

export { useNexal2 } from './useNexal2';
</file>

<file path="hooks/useNexal2.ts">
/**
 * NEXAL2 Feature Flag Hook
 *
 * Controls whether NEXAL2 engine is used for preview and export.
 * Can be enabled via:
 * - URL query param: ?engine=nexal2
 * - Manual toggle in dev mode
 */

import { useState, useEffect, useCallback } from 'react';
import { useSearchParams } from 'react-router-dom';

type Engine = 'legacy' | 'nexal2';

interface UseNexal2Result {
    engine: Engine;
    isNexal2: boolean;
    toggleEngine: () => void;
}

/**
 * Hook to check if NEXAL2 engine should be used.
 * Priority: URL param > localStorage > default (legacy)
 */
export function useNexal2(): UseNexal2Result {
    const [searchParams, setSearchParams] = useSearchParams();
    const urlEngine = searchParams.get('engine') as Engine | null;

    // Default to legacy unless URL says nexal2
    const [engine, setEngine] = useState<Engine>(() => {
        if (urlEngine === 'nexal2') return 'nexal2';
        if (urlEngine === 'legacy') return 'legacy';
        // Check localStorage for dev preference
        const stored = localStorage.getItem('nexal2-engine');
        if (stored === 'nexal2') return 'nexal2';
        return 'legacy';
    });

    // Sync URL param changes
    useEffect(() => {
        if (urlEngine === 'nexal2' && engine !== 'nexal2') {
            setEngine('nexal2');
        } else if (urlEngine === 'legacy' && engine !== 'legacy') {
            setEngine('legacy');
        }
    }, [urlEngine, engine]);

    // Toggle engine (updates URL and localStorage)
    const toggleEngine = useCallback(() => {
        const newEngine = engine === 'nexal2' ? 'legacy' : 'nexal2';
        setEngine(newEngine);
        localStorage.setItem('nexal2-engine', newEngine);
        // Update URL param
        const newParams = new URLSearchParams(searchParams);
        newParams.set('engine', newEngine);
        setSearchParams(newParams, { replace: true });
        console.log(`[NEXAL2] Engine switched to: ${newEngine}`);
    }, [engine, searchParams, setSearchParams]);

    return {
        engine,
        isNexal2: engine === 'nexal2',
        toggleEngine,
    };
}

export default useNexal2;
</file>

<file path="index.ts">
/**
 * NEXAL2 - SceneGraph Architecture
 *
 * Parallel rendering pipeline (feature flag: VITE_NEXAL2=1)
 *
 * Usage:
 *   const constraints = createConstraints({ regionId: 'FR', presetId: 'SIDEBAR' });
 *   const scene = buildScene(profile, design);
 *   const layout = computeLayout(scene, constraints);
 *   <HTMLRenderer layout={layout} /> // or <PDFRenderer layout={layout} />
 */

// Types
export * from './types';

// Constraints (CV Chameleon)
export * from './constraints';

// SceneGraph
export { buildScene } from './scenegraph';

// Layout
export { computeLayout, measureText, paginateLayout } from './layout';

// Renderers
export { HTMLRenderer, EditableHTMLRenderer } from './renderers/html';
export { PDFRenderer } from './renderers/pdf';

// Hooks
export { useNexal2 } from './hooks';

// Adapters
export { mapAppToNexal2, mapProfileToNexal2, mapDesignToNexal2 } from './adapters';

// Components
export { NEXAL2PreviewPane } from './components';

// Dev tools (validation, matrix runner)
export * from './dev';
</file>

<file path="layout/computeLayout.ts">
/**
 * NEXAL2 - Layout Engine
 *
 * Computes absolute positions for all SceneNodes.
 * Pure function, deterministic output.
 *
 * Phase 2.3: Added nodeType propagation and style inheritance.
 * Phase 4.5: Multi-page pagination support.
 */

import type {
    SceneDocument,
    SceneNode,
    SceneNodeType,
    SceneStyle,
    LayoutTree,
    LayoutNode,
    LayoutConstraints,
    LayoutFrame,
    ComputedStyle,
    TextMeasurement,
} from '../types';
import { DEFAULT_NEXAL_THEME, PAPER_DIMENSIONS as PAPER } from '../types';
import { paginateLayout } from './paginateLayout';

// ============================================================================
// DEFAULT TEXT STYLE (safe fallback for all text)
// ============================================================================

const DEFAULT_TEXT_STYLE: ComputedStyle = {
    fontSize: DEFAULT_NEXAL_THEME.fontSize.body,
    lineHeight: DEFAULT_NEXAL_THEME.lineHeight,
    color: '#1F2937',
    fontWeight: 'normal',
    fontFamily: 'Helvetica, Arial, sans-serif',
    textAlign: 'left',
    textTransform: 'none',
    letterSpacing: undefined,
    backgroundColor: undefined,
};

// ============================================================================
// MAIN LAYOUT FUNCTION
// ============================================================================

/**
 * Compute the layout tree from a SceneDocument.
 *
 * @param scene - The scene document to layout
 * @param constraints - Layout constraints (can be ChameleonConstraints with frames/tokens)
 * @returns A complete LayoutTree with absolute positions
 * 
 * IMPORTANT: constraints.paper is the source of truth when present (ChameleonConstraints).
 * This ensures paper dimensions match the frames computed by presets.
 */
export function computeLayout(
    scene: SceneDocument,
    constraints: LayoutConstraints
): LayoutTree {
    // Use constraints.paper as source of truth (ChameleonConstraints)
    // Fallback to scene.paperFormat for legacy constraints
    const chameleonPaper = (constraints as any).paper;
    const chameleonFormat = (constraints as any).paperFormat;

    const paper = chameleonPaper ?? PAPER[scene.paperFormat];
    const paperFormat = chameleonFormat ?? scene.paperFormat;

    // Dev warning if paper formats mismatch
    if (chameleonFormat && scene.paperFormat !== chameleonFormat) {
        console.warn('[NEXAL2] paperFormat mismatch (constraints takes priority)', {
            scene: scene.paperFormat,
            constraints: chameleonFormat
        });
    }

    // Build root text style from tokens (if present)
    const tokens = (constraints as any).tokens;
    const rootTextStyle: ComputedStyle = tokens ? {
        ...DEFAULT_TEXT_STYLE,
        fontSize: tokens.fontSize?.body ?? DEFAULT_TEXT_STYLE.fontSize,
        lineHeight: tokens.lineHeight ?? DEFAULT_TEXT_STYLE.lineHeight,
    } : DEFAULT_TEXT_STYLE;

    // Layout each page with root style
    const layoutPages: LayoutNode[] = scene.pages.map((pageNode) => {
        return layoutPage(pageNode, constraints, paper, rootTextStyle);
    });

    // Build initial single-page layout
    const singlePageLayout: LayoutTree = {
        pages: layoutPages,
        bounds: {
            width: paper.width,
            height: paper.height,
        },
        constraints,
    };

    // Phase 4.5: Apply pagination if content overflows
    return paginateLayout(singlePageLayout, constraints);
}

// ============================================================================
// PAGE LAYOUT
// ============================================================================

/**
 * Layout a single page node.
 * 
 * FRAME-DRIVEN: Uses constraints.frames (from ChameleonConstraints) for positioning.
 * No more manual margin calculations - frames are pre-computed by presets.
 */
function layoutPage(
    pageNode: SceneNode,
    constraints: LayoutConstraints,
    paper: { width: number; height: number },
    parentStyle: ComputedStyle
): LayoutNode {
    const children: LayoutNode[] = [];
    const pageStyle = resolveComputedStyle(pageNode.style, parentStyle);

    // Find containers in scene
    const sidebarNode = pageNode.children?.find(c => c.id === 'sidebar');
    const mainNode = pageNode.children?.find(c => c.id === 'main');
    const headerNode = pageNode.children?.find(c => c.id === 'header');
    // Phase 4.2: New container types
    const leftRailNode = pageNode.children?.find(c => c.id === 'leftRail');
    const rightRailNode = pageNode.children?.find(c => c.id === 'rightRail');
    const headerLeftNode = pageNode.children?.find(c => c.id === 'headerLeft');
    const headerRightNode = pageNode.children?.find(c => c.id === 'headerRight');

    // Check if we have frame-driven constraints (ChameleonConstraints)
    const frames = (constraints as any).frames;

    if (frames) {
        // FRAME-DRIVEN LAYOUT: Use pre-computed frames from presets

        // Layout header (if frame and node exist)
        if (frames.header && headerNode) {
            const headerLayout = layoutContainer(
                headerNode,
                {
                    x: frames.header.x,
                    y: frames.header.y,
                    width: frames.header.width,
                    height: frames.header.height
                },
                constraints,
                pageStyle
            );
            children.push(headerLayout);
        }

        // Layout headerLeft (SPLIT_HEADER preset)
        if (frames.headerLeft && headerLeftNode) {
            const headerLeftLayout = layoutContainer(
                headerLeftNode,
                {
                    x: frames.headerLeft.x,
                    y: frames.headerLeft.y,
                    width: frames.headerLeft.width,
                    height: frames.headerLeft.height
                },
                constraints,
                pageStyle
            );
            children.push(headerLeftLayout);
        }

        // Layout headerRight (SPLIT_HEADER preset)
        if (frames.headerRight && headerRightNode) {
            const headerRightLayout = layoutContainer(
                headerRightNode,
                {
                    x: frames.headerRight.x,
                    y: frames.headerRight.y,
                    width: frames.headerRight.width,
                    height: frames.headerRight.height
                },
                constraints,
                pageStyle
            );
            children.push(headerRightLayout);
        }

        // Layout leftRail (LEFT_RAIL / DUAL_SIDEBAR presets)
        if (frames.leftRail && leftRailNode) {
            const leftRailLayout = layoutContainer(
                leftRailNode,
                {
                    x: frames.leftRail.x,
                    y: frames.leftRail.y,
                    width: frames.leftRail.width,
                    height: frames.leftRail.height
                },
                constraints,
                pageStyle
            );
            children.push(leftRailLayout);
        }

        // Layout rightRail (DUAL_SIDEBAR preset)
        if (frames.rightRail && rightRailNode) {
            const rightRailLayout = layoutContainer(
                rightRailNode,
                {
                    x: frames.rightRail.x,
                    y: frames.rightRail.y,
                    width: frames.rightRail.width,
                    height: frames.rightRail.height
                },
                constraints,
                pageStyle
            );
            children.push(rightRailLayout);
        }

        // Layout sidebar (if frame and node exist)
        if (frames.sidebar && sidebarNode) {
            const sidebarLayout = layoutContainer(
                sidebarNode,
                {
                    x: frames.sidebar.x,
                    y: frames.sidebar.y,
                    width: frames.sidebar.width,
                    height: frames.sidebar.height
                },
                constraints,
                pageStyle
            );
            children.push(sidebarLayout);
        }

        // Layout main (always exists)
        if (mainNode && frames.main) {
            const mainLayout = layoutContainer(
                mainNode,
                {
                    x: frames.main.x,
                    y: frames.main.y,
                    width: frames.main.width,
                    height: frames.main.height
                },
                constraints,
                pageStyle
            );
            children.push(mainLayout);
        }
    } else {
        // LEGACY FALLBACK: Old constraints without frames
        const sidebarX = constraints.sidebarPosition === 'left' ? 0 : paper.width - constraints.sidebarWidth;
        const mainX = constraints.sidebarPosition === 'left'
            ? constraints.sidebarWidth + constraints.sidebarGap
            : 0;
        const mainWidth = paper.width - constraints.sidebarWidth - constraints.sidebarGap;

        if (sidebarNode) {
            const sidebarLayout = layoutContainer(
                sidebarNode,
                { x: sidebarX, y: 0, width: constraints.sidebarWidth, height: paper.height },
                constraints,
                pageStyle
            );
            children.push(sidebarLayout);
        }

        if (mainNode) {
            const mainLayout = layoutContainer(
                mainNode,
                {
                    x: mainX + constraints.margins.left,
                    y: constraints.margins.top,
                    width: mainWidth - constraints.margins.left - constraints.margins.right,
                    height: paper.height - constraints.margins.top - constraints.margins.bottom
                },
                constraints,
                pageStyle
            );
            children.push(mainLayout);
        }
    }

    return {
        nodeId: pageNode.id,
        nodeType: pageNode.type,
        frame: { x: 0, y: 0, width: paper.width, height: paper.height },
        children,
        computedStyle: pageStyle,
    };
}

// ============================================================================
// CONTAINER LAYOUT
// ============================================================================

/**
 * Layout a container node (section, container, list, etc.)
 * 
 * Phase 5.2: Supports flex-like alignment:
 * - direction: 'row' | 'column' (default: 'column')
 * - alignItems: cross-axis alignment ('start' | 'center' | 'end')
 * - justifyContent: main-axis distribution ('start' | 'center' | 'end' | 'spaceBetween')
 * 
 * IMPORTANT: Children use RELATIVE coordinates to this container,
 * not absolute page coordinates.
 */
function layoutContainer(
    node: SceneNode,
    availableFrame: LayoutFrame,
    constraints: LayoutConstraints,
    parentStyle: ComputedStyle
): LayoutNode {
    const style = node.style || {};
    const computedStyle = resolveComputedStyle(style, parentStyle);

    const paddingTop = style.paddingTop || 0;
    const paddingBottom = style.paddingBottom || 0;
    const paddingLeft = style.paddingLeft || 0;
    const paddingRight = style.paddingRight || 0;
    const gap = style.gap || DEFAULT_NEXAL_THEME.spacing.subsectionMargin;

    // Phase 5.2: Flex-like properties
    const direction = style.direction || 'column';
    const alignItems = style.alignItems || 'start';
    const justifyContent = style.justifyContent || 'start';

    // Inner dimensions (after padding)
    const innerWidth = availableFrame.width - paddingLeft - paddingRight;
    const innerHeight = availableFrame.height - paddingTop - paddingBottom;

    // First pass: layout all children to get their natural sizes
    const childLayouts: LayoutNode[] = [];
    for (const child of node.children || []) {
        // Skip empty text/listItem nodes early
        const isTextish = child.type === 'text' || child.type === 'listItem';
        const rawContent = (child.content ?? '');
        if (isTextish && rawContent.trim().length === 0) {
            continue;
        }

        // Layout child with available width (for row: estimate, will adjust)
        const childWidth = direction === 'row'
            ? (child.style?.width && typeof child.style.width === 'number' ? child.style.width : innerWidth)
            : innerWidth;

        const childLayout = layoutNode(
            child,
            { x: 0, y: 0, width: childWidth, height: 0 },
            constraints,
            computedStyle
        );

        // Skip zero-height empty content
        if ((childLayout.nodeType === 'text' || childLayout.nodeType === 'listItem')
            && (childLayout.content ?? '').trim().length === 0) {
            continue;
        }

        childLayouts.push(childLayout);
    }

    // Calculate total size along main axis
    let totalMainSize = 0;
    let maxCrossSize = 0;

    for (const child of childLayouts) {
        if (direction === 'row') {
            totalMainSize += child.frame.width;
            maxCrossSize = Math.max(maxCrossSize, child.frame.height);
        } else {
            totalMainSize += child.frame.height;
            maxCrossSize = Math.max(maxCrossSize, child.frame.width);
        }
    }

    if (childLayouts.length > 1) {
        totalMainSize += gap * (childLayouts.length - 1);
    }

    // Phase 5.2: Calculate main-axis starting position and spacing
    let mainAxisStart: number;
    let spacing = gap;

    if (direction === 'row') {
        const availableMainSpace = innerWidth;
        // Phase 5.3: freeSpace = available - total (totalMainSize already includes gaps)
        const freeSpace = availableMainSpace - totalMainSize;

        switch (justifyContent) {
            case 'center':
                mainAxisStart = paddingLeft + Math.max(0, freeSpace / 2);
                break;
            case 'end':
                mainAxisStart = paddingLeft + Math.max(0, freeSpace);
                break;
            case 'spaceBetween':
                mainAxisStart = paddingLeft;
                if (childLayouts.length > 1) {
                    const totalChildWidth = childLayouts.reduce((sum, c) => sum + c.frame.width, 0);
                    spacing = (availableMainSpace - totalChildWidth) / (childLayouts.length - 1);
                }
                break;
            default: // 'start'
                mainAxisStart = paddingLeft;
        }
    } else {
        const availableMainSpace = innerHeight > 0 ? innerHeight : 9999;
        // Phase 5.3: freeSpace = available - total (totalMainSize already includes gaps)
        const freeSpace = availableMainSpace - totalMainSize;

        switch (justifyContent) {
            case 'center':
                mainAxisStart = paddingTop + Math.max(0, freeSpace / 2);
                break;
            case 'end':
                mainAxisStart = paddingTop + Math.max(0, freeSpace);
                break;
            case 'spaceBetween':
                mainAxisStart = paddingTop;
                if (childLayouts.length > 1) {
                    const totalChildHeight = childLayouts.reduce((sum, c) => sum + c.frame.height, 0);
                    spacing = (availableMainSpace - totalChildHeight) / (childLayouts.length - 1);
                }
                break;
            default: // 'start'
                mainAxisStart = paddingTop;
        }
    }

    // Phase 5.2: Position children with alignment
    // Phase 5.3: Fixed - only add spacing between children, not after last
    let mainAxisPos = mainAxisStart;
    const positionedChildren: LayoutNode[] = [];

    for (let i = 0; i < childLayouts.length; i++) {
        const child = childLayouts[i];
        const isLast = i === childLayouts.length - 1;
        let childX: number;
        let childY: number;

        if (direction === 'row') {
            // Main axis is X
            childX = mainAxisPos;
            mainAxisPos += child.frame.width + (isLast ? 0 : spacing);

            // Cross axis is Y - apply alignItems
            const crossAvailable = innerHeight > 0 ? innerHeight : child.frame.height;
            switch (alignItems) {
                case 'center':
                    childY = paddingTop + (crossAvailable - child.frame.height) / 2;
                    break;
                case 'end':
                    childY = paddingTop + crossAvailable - child.frame.height;
                    break;
                default: // 'start'
                    childY = paddingTop;
            }
        } else {
            // Main axis is Y
            childY = mainAxisPos;
            mainAxisPos += child.frame.height + (isLast ? 0 : spacing);

            // Cross axis is X - apply alignItems
            switch (alignItems) {
                case 'center':
                    childX = paddingLeft + (innerWidth - child.frame.width) / 2;
                    break;
                case 'end':
                    childX = paddingLeft + innerWidth - child.frame.width;
                    break;
                default: // 'start'
                    childX = paddingLeft;
            }
        }

        positionedChildren.push({
            ...child,
            frame: {
                ...child.frame,
                x: childX,
                y: childY,
            },
        });
    }

    // Calculate container's natural height
    const contentHeight = direction === 'column'
        ? (mainAxisPos - paddingTop + paddingBottom)
        : (maxCrossSize + paddingTop + paddingBottom);

    return {
        nodeId: node.id,
        nodeType: node.type,
        frame: {
            x: availableFrame.x,
            y: availableFrame.y,
            width: availableFrame.width,
            height: Math.max(contentHeight, availableFrame.height),
        },
        children: positionedChildren,
        computedStyle,
    };
}

// ============================================================================
// NODE LAYOUT
// ============================================================================

/**
 * Layout a single node (text, image, section, etc.)
 * Style inheritance: child inherits from parent unless explicitly overridden.
 */
function layoutNode(
    node: SceneNode,
    availableFrame: LayoutFrame,
    constraints: LayoutConstraints,
    parentStyle: ComputedStyle
): LayoutNode {
    const style = node.style || {};
    const computedStyle = resolveComputedStyle(style, parentStyle);

    switch (node.type) {
        case 'text': {
            const measurement = measureText(
                node.content || '',
                { fontSize: computedStyle.fontSize, fontFamily: 'sans', lineHeight: computedStyle.lineHeight },
                availableFrame.width
            );
            return {
                nodeId: node.id,
                nodeType: node.type,
                frame: {
                    x: availableFrame.x,
                    y: availableFrame.y,
                    width: availableFrame.width,
                    height: measurement.height,
                },
                computedStyle,
                content: node.content,
                fieldPath: node.fieldPath,
            };
        }

        case 'listItem': {
            // Reserve space for bullet in measurement (bullet + gap)
            const BULLET_INDENT_PT = 10;
            const measurement = measureText(
                node.content || '',
                { fontSize: computedStyle.fontSize, fontFamily: 'sans', lineHeight: computedStyle.lineHeight },
                availableFrame.width - BULLET_INDENT_PT
            );
            return {
                nodeId: node.id,
                nodeType: node.type,
                frame: {
                    x: availableFrame.x,
                    y: availableFrame.y,
                    width: availableFrame.width,
                    height: measurement.height,
                },
                computedStyle,
                content: node.content,
                fieldPath: node.fieldPath,
            };
        }

        case 'image': {
            // Get size from style or default
            const size = (style.width as number) || 80;
            return {
                nodeId: node.id,
                nodeType: node.type,
                frame: {
                    x: availableFrame.x + (availableFrame.width - size) / 2,
                    y: availableFrame.y,
                    width: size,
                    height: size,
                },
                computedStyle,
                content: node.content,
                fieldPath: node.fieldPath,
            };
        }

        case 'section':
        case 'container':
        case 'list': {
            // CRITICAL: Pass computedStyle (not parentStyle) so children inherit from THIS node
            return layoutContainer(node, { ...availableFrame, height: 0 }, constraints, computedStyle);
        }

        case 'spacer': {
            const height = (style.height as number) || 10;
            return {
                nodeId: node.id,
                nodeType: node.type,
                frame: { ...availableFrame, height },
                computedStyle,
            };
        }

        default:
            return {
                nodeId: node.id,
                nodeType: node.type,
                frame: availableFrame,
                computedStyle,
            };
    }
}

// ============================================================================
// STYLE INHERITANCE
// ============================================================================

/**
 * Resolve a SceneStyle to a ComputedStyle with inheritance.
 * Child style properties override parent, otherwise inherit.
 *
 * INHERITED properties: color, fontFamily, fontSize, lineHeight, fontWeight,
 *                       textAlign, textTransform, letterSpacing
 * NON-INHERITED: backgroundColor (must be explicit)
 */
function resolveComputedStyle(
    nodeStyle: Partial<SceneStyle> | undefined,
    parentStyle: ComputedStyle
): ComputedStyle {
    const style = nodeStyle || {};
    return {
        // Inherited properties (child overrides or inherits from parent)
        fontSize: style.fontSize ?? parentStyle.fontSize,
        lineHeight: style.lineHeight ?? parentStyle.lineHeight,
        color: style.color ?? parentStyle.color,
        fontWeight: style.fontWeight ?? parentStyle.fontWeight,
        fontFamily: style.fontFamily ? mapFontFamily(style.fontFamily) : parentStyle.fontFamily,
        textAlign: style.textAlign ?? parentStyle.textAlign,
        textTransform: style.textTransform ?? parentStyle.textTransform,
        letterSpacing: style.letterSpacing ?? parentStyle.letterSpacing,
        // Non-inherited (explicit only)
        backgroundColor: style.backgroundColor,
    };
}

// ============================================================================
// TEXT MEASUREMENT
// ============================================================================

/**
 * Measure text dimensions with improved word-wrap estimation.
 * 
 * IMPROVED: Handles newlines, word wrapping, and long-word breaking.
 * Conservative estimation to prevent PDF overlap.
 */
export function measureText(
    text: string,
    style: { fontSize: number; fontFamily: string; lineHeight: number },
    maxWidth: number
): TextMeasurement {
    if (!text || text.length === 0) {
        return { width: 0, height: 0, lineCount: 0 };
    }

    // Approximate character width based on font size
    // Using 0.55 (slightly wider than average) to be conservative
    const avgCharWidth = style.fontSize * 0.55;
    const maxCharsPerLine = Math.max(1, Math.floor(maxWidth / avgCharWidth));
    const lineHeightPx = style.fontSize * style.lineHeight;

    // Split by explicit newlines first
    const paragraphs = text.split('\n');
    let totalLines = 0;
    let maxLineWidth = 0;

    for (const para of paragraphs) {
        if (para.length === 0) {
            // Empty line (just a newline)
            totalLines += 1;
            continue;
        }

        // Split paragraph into words
        const words = para.split(/\s+/).filter(w => w.length > 0);
        if (words.length === 0) {
            totalLines += 1;
            continue;
        }

        let currentLineChars = 0;
        let lineCount = 1;

        for (const word of words) {
            const wordLen = word.length;

            // Handle very long words (must break them)
            if (wordLen > maxCharsPerLine) {
                // If we already have content on current line, wrap first
                if (currentLineChars > 0) {
                    lineCount++;
                    currentLineChars = 0;
                }
                // Break the long word into chunks
                const chunks = Math.ceil(wordLen / maxCharsPerLine);
                lineCount += chunks - 1; // -1 because first chunk starts on current line
                currentLineChars = wordLen % maxCharsPerLine || maxCharsPerLine;
            } else {
                // Normal word - check if it fits on current line
                const neededSpace = currentLineChars > 0 ? wordLen + 1 : wordLen; // +1 for space
                if (currentLineChars + neededSpace > maxCharsPerLine) {
                    // Word doesn't fit, wrap to next line
                    lineCount++;
                    currentLineChars = wordLen;
                } else {
                    // Word fits, add to current line
                    currentLineChars += neededSpace;
                }
            }

            // Track max line width
            if (currentLineChars * avgCharWidth > maxLineWidth) {
                maxLineWidth = currentLineChars * avgCharWidth;
            }
        }

        totalLines += lineCount;
    }

    // Add a safety buffer of 1 line for complex text (fudge factor)
    // This prevents overlap in edge cases
    if (totalLines > 2 && text.length > maxCharsPerLine * 2) {
        totalLines += 1;
    }

    const height = totalLines * lineHeightPx;

    return {
        width: Math.min(maxLineWidth, maxWidth),
        height,
        lineCount: totalLines,
    };
}

// ============================================================================
// FONT FAMILY MAPPING
// ============================================================================

/**
 * Map font family enum to actual font names.
 */
function mapFontFamily(family: 'sans' | 'serif' | 'mono'): string {
    switch (family) {
        case 'sans': return 'Helvetica, Arial, sans-serif';
        case 'serif': return 'Times New Roman, Times, serif';
        case 'mono': return 'Courier New, Courier, monospace';
        default: return 'Helvetica, Arial, sans-serif';
    }
}

export default computeLayout;
</file>

<file path="layout/index.ts">
/**
 * NEXAL2 - Layout Module
 */

export { computeLayout, measureText } from './computeLayout';
export { paginateLayout, type PaginationOptions, type PaginationResult } from './paginateLayout';
</file>

<file path="layout/paginateLayout.ts">
/**
 * NEXAL2 - Pagination System
 * 
 * Splits a single-page layout into multiple pages when content overflows.
 * 
 * Phase 4.5: Multi-page pagination with smart splitting rules.
 * Phase 4.6: Fixed page coords (y=0 per page) for PDF parity, fixed splitIndex application.
 * Phase 4.7: Hardening (child.frame.y, oversized handling).
 * Phase 4.8: Production-grade split scoring, keepWithNext/keepTogether semantics.
 * 
 * Algorithm:
 * 1. Take the single-page layout (page-1) with main container
 * 2. Find the main container and calculate available height
 * 3. Walk main's children, applying keep rules
 * 4. When overflow detected, score candidate split points:
 *    - Prefer after complete sections (+100)
 *    - Prefer after list blocks (+50)
 *    - Penalize violating keepWithNext (-1000)
 *    - Penalize breaking keepTogether (-500)
 *    - Penalize lonely title at bottom (-200)
 * 5. Create additional pages with remaining content (each page has y=0 for PDF parity)
 * 6. Return multi-page LayoutTree with validation warnings
 */

import type { LayoutNode, LayoutTree, LayoutConstraints, LayoutFrame, PaginationMeta, PaginationWarning } from '../types';

// ============================================================================
// TYPES
// ============================================================================

export interface PaginationOptions {
    /** Minimum lines to keep with a section title (orphan prevention) */
    minOrphans?: number;
    /** Minimum lines to leave on a new page (widow prevention) */
    minWidows?: number;
    /** Try to keep this many items together before breaking */
    keepTogetherThreshold?: number;
    /** Repeat sidebar/rails on all pages (default: false - sidebar only on page 1) */
    repeatSidebarOnAllPages?: boolean;
}

export interface PaginationResult {
    pages: LayoutNode[];
    pageCount: number;
    didPaginate: boolean;
    splitPoints: number[]; // Y positions where splits occurred (in original content space)
    warnings: PaginationWarning[]; // Phase 4.8: Structured warnings
}

// PaginationWarning is now imported from types.ts
export type { PaginationWarning };

/** Phase 4.8: Keep rule for a node */
type KeepRule = 'keepWithNext' | 'keepTogether' | 'normal';

interface SplitCandidate {
    node: LayoutNode;
    index: number;
    startY: number;
    endY: number;
    isSectionTitle: boolean;
    isSection: boolean;
    keepRule: KeepRule; // Phase 4.8
}

// ============================================================================
// CONSTANTS
// ============================================================================

const DEFAULT_OPTIONS: Required<PaginationOptions> = {
    minOrphans: 2,  // Keep at least 2 items with a section title
    minWidows: 1,   // Keep at least 1 item on new page
    keepTogetherThreshold: 3, // Try to keep up to 3 items together
    repeatSidebarOnAllPages: false, // FIX P0: Sidebar only on page 1 by default
};

// Phase 4.8: Split scoring weights
const SCORE_AFTER_SECTION = 100;
const SCORE_AFTER_LIST_BLOCK = 50;
const PENALTY_KEEP_WITH_NEXT = -1000;
const PENALTY_KEEP_TOGETHER = -500;
const PENALTY_LONELY_TITLE = -200;

// ============================================================================
// PHASE 4.8: KEEP RULES
// ============================================================================

/**
 * Phase 4.9: Determine keep rule using fieldPath (stable) or nodeType.
 * Avoids fragile nodeId string matching.
 */
function getKeepRule(node: LayoutNode): KeepRule {
    const { nodeType, fieldPath } = node;

    // Phase 4.9: Use fieldPath for stable identification
    if (fieldPath) {
        // Section titles by fieldPath
        if (fieldPath.endsWith('.title') || fieldPath.includes('_title')) {
            return 'keepWithNext';
        }

        // Experience headers should stay with content
        if (fieldPath.startsWith('experiences[') &&
            (fieldPath.includes('.company') || fieldPath.includes('.role') || fieldPath.endsWith('].header'))) {
            return 'keepTogether';
        }

        // Education headers should stay with content
        if (fieldPath.startsWith('educations[') &&
            (fieldPath.includes('.school') || fieldPath.includes('.degree') || fieldPath.endsWith('].header'))) {
            return 'keepTogether';
        }

        // Section block patterns
        if (fieldPath.match(/^(experiences|educations|skills|languages)$/)) {
            return 'keepTogether';
        }
    }

    // Fallback to nodeType-based rules
    // Section titles by style (uppercase)
    if (nodeType === 'text' && node.computedStyle?.textTransform === 'uppercase') {
        return 'keepWithNext';
    }

    // Section blocks should generally try to stay together
    if (nodeType === 'section') {
        return 'keepTogether';
    }

    return 'normal';
}

// ============================================================================
// MAIN PAGINATION FUNCTION
// ============================================================================

/**
 * Paginate a layout tree, splitting content across multiple pages as needed.
 * 
 * Each page has frame.y = 0 (local coordinates) for PDF parity.
 * HTML renderer stacks pages vertically; PDF renderer treats each page independently.
 * 
 * @param layout - Single-page layout tree
 * @param constraints - Layout constraints (for frame info)
 * @param options - Pagination options
 * @returns Paginated layout tree with multiple pages
 */
export function paginateLayout(
    layout: LayoutTree,
    constraints: LayoutConstraints,
    options: PaginationOptions = {}
): LayoutTree {
    const opts = { ...DEFAULT_OPTIONS, ...options };

    // Get first page
    const firstPage = layout.pages[0];
    if (!firstPage) return layout;

    // Get paper dimensions and frames
    const paper = layout.bounds;
    const frames = (constraints as any).frames;

    // Calculate available height for main content
    const mainFrame = frames?.main;
    if (!mainFrame) {
        // No main frame, return as-is
        return layout;
    }

    const availableHeight = mainFrame.height;

    // Find main container in page
    const mainContainer = findNode(firstPage, 'main');
    if (!mainContainer || !mainContainer.children?.length) {
        return layout; // No main content to paginate
    }

    // Analyze content and gather split candidates with keep rules
    // Phase 5.4: Pass availableHeight to enable oversized section expansion
    const candidates = analyzeMainContent(mainContainer, availableHeight);

    // Check if pagination is needed
    const totalHeight = candidates.length > 0
        ? candidates[candidates.length - 1].endY
        : 0;

    if (totalHeight <= availableHeight) {
        // No pagination needed - but still generate signature for CI gate
        console.log('[NEXAL2 Pagination] No pagination needed:', { totalHeight, availableHeight });

        // Phase 5.5: Generate signature even for single-page layouts
        const singlePageSignature = computePageSignature(firstPage);

        return {
            ...layout,
            paginationMeta: {
                pageCount: 1,
                didPaginate: false,
                splitPoints: [],
                warnings: [],
                pageSignatures: [singlePageSignature],
            },
        };
    }

    console.log('[NEXAL2 Pagination] Pagination required:', {
        totalHeight,
        availableHeight,
        candidateCount: candidates.length
    });

    // Perform pagination with scoring
    const paginationResult = splitIntoPages(
        candidates,
        availableHeight,
        opts,
        paper,
        mainFrame,
        firstPage,
        frames,
        mainContainer
    );

    console.log('[NEXAL2 Pagination] Result:', {
        pageCount: paginationResult.pageCount,
        splitPoints: paginationResult.splitPoints,
        warningCount: paginationResult.warnings.length,
    });

    // Log warnings
    paginationResult.warnings.forEach(warn => {
        console.warn(`[NEXAL2 Pagination] ${warn.code}: ${warn.message}`);
    });

    // Phase 4.9: Generate per-page parity signatures
    const pageSignatures = paginationResult.pages.map(page => computePageSignature(page));

    // Build new layout tree with per-page bounds and paginationMeta
    return {
        ...layout,
        pages: paginationResult.pages,
        bounds: {
            width: paper.width,
            // For HTML preview: total height = pageCount * pageHeight
            height: paper.height * paginationResult.pageCount,
        },
        // Phase 4.9: Attach pagination metadata
        paginationMeta: {
            pageCount: paginationResult.pageCount,
            didPaginate: paginationResult.didPaginate,
            splitPoints: paginationResult.splitPoints,
            warnings: paginationResult.warnings,
            pageSignatures,
        },
    };
}

// ============================================================================
// ANALYSIS HELPERS
// ============================================================================

/**
 * Analyze main container children for split candidates.
 * Phase 4.8: Includes keep rules for each candidate.
 * Phase 5.4: Expands oversized sections into their children for splittable pagination.
 */
function analyzeMainContent(mainContainer: LayoutNode, availableHeight?: number): SplitCandidate[] {
    const candidates: SplitCandidate[] = [];

    mainContainer.children?.forEach((child, _index) => {
        // Phase 4.7: Use child.frame.y directly for robustness
        const startY = child.frame.y;
        const endY = startY + child.frame.height;
        const nodeHeight = child.frame.height;

        // Detect section titles
        const isSectionTitle = child.nodeType === 'text' &&
            (child.nodeId.includes('.title') ||
                child.computedStyle?.textTransform === 'uppercase');

        const isSection = child.nodeType === 'section';

        // Phase 5.4: Check if section is oversized and should be expanded
        const isOversized = availableHeight !== undefined && nodeHeight > availableHeight;
        const hasChildren = isSection && child.children && child.children.length > 0;

        // Phase 5.5: Force-expand main.experience and main.education to avoid "page 1 empty" issue
        // These sections should always be splittable, even if they fit on one page
        const forceExpandIds = ['main.experience', 'main.education'];
        const shouldForceExpand = hasChildren && forceExpandIds.includes(child.nodeId);

        if ((isOversized || shouldForceExpand) && hasChildren) {
            // Phase 5.4/5.5: Expand section into its children as separate candidates
            if (isOversized) {
                console.log(`[NEXAL2 Pagination] Expanding oversized section ${child.nodeId} (${nodeHeight.toFixed(1)}pt > ${availableHeight?.toFixed(1)}pt)`);
            } else {
                console.log(`[NEXAL2 Pagination] Force-expanding splittable section ${child.nodeId}`);
            }

            // CRITICAL FIX: Section children have frame.y relative to the SECTION, not main container.
            // We must add the section's startY (its Y within main) to get absolute coordinates.
            const sectionOffsetY = startY;

            let prevWasTitle = false;
            child.children?.forEach((sectionChild, sectionChildIndex) => {
                // Use section's offset + child's relative Y to get absolute Y within main
                const sChildStartY = sectionOffsetY + sectionChild.frame.y;
                const sChildEndY = sChildStartY + sectionChild.frame.height;

                // Section title detection
                const isChildSectionTitle = sectionChild.nodeType === 'text' &&
                    (sectionChild.nodeId.includes('.title') ||
                        sectionChild.computedStyle?.textTransform === 'uppercase');

                // Phase 5.4: keepWithNext for title, keepTogether for first item after title
                let keepRule: KeepRule = 'normal';
                if (isChildSectionTitle) {
                    keepRule = 'keepWithNext';
                } else if (prevWasTitle && sectionChildIndex > 0) {
                    // First item after title - normal (title will keep with it)
                    keepRule = 'normal';
                } else {
                    keepRule = getKeepRule(sectionChild);
                }

                candidates.push({
                    node: sectionChild,
                    index: candidates.length,
                    startY: sChildStartY,
                    endY: sChildEndY,
                    isSectionTitle: isChildSectionTitle,
                    isSection: sectionChild.nodeType === 'section',
                    keepRule,
                });

                prevWasTitle = isChildSectionTitle;
            });
        } else {
            // Normal case: add section as single candidate
            const keepRule = getKeepRule(child);

            candidates.push({
                node: child,
                index: candidates.length,
                startY,
                endY,
                isSectionTitle,
                isSection,
                keepRule,
            });
        }
    });

    return candidates;
}

/**
 * Find a node by ID in the layout tree.
 */
function findNode(root: LayoutNode, id: string): LayoutNode | null {
    if (root.nodeId === id) return root;
    for (const child of root.children || []) {
        const found = findNode(child, id);
        if (found) return found;
    }
    return null;
}

// ============================================================================
// SPLITTING LOGIC (Phase 4.8: Scoring-based split selection)
// ============================================================================

/**
 * Split main content into multiple pages using scoring-based selection.
 */
function splitIntoPages(
    candidates: SplitCandidate[],
    availableHeight: number,
    opts: Required<PaginationOptions>,
    paper: { width: number; height: number },
    mainFrame: LayoutFrame,
    firstPage: LayoutNode,
    frames: any,
    mainContainer: LayoutNode
): PaginationResult {
    const pages: LayoutNode[] = [];
    const splitPoints: number[] = [];
    const warnings: PaginationWarning[] = [];

    let startIndex = 0;
    let pageIndex = 0;
    let contentOffsetY = 0; // Cumulative Y offset from original content

    while (startIndex < candidates.length) {
        // Find where this page should end using scoring
        const { endIndex, splitY, pageWarnings } = findBestPageEnd(
            candidates,
            startIndex,
            contentOffsetY,
            availableHeight,
            opts
        );

        warnings.push(...pageWarnings);

        // Collect children for this page
        const pageMainChildren: LayoutNode[] = [];
        for (let i = startIndex; i <= endIndex; i++) {
            const candidate = candidates[i];
            // Clone with Y offset relative to page start
            const offsetNode = cloneWithOffsetY(candidate.node, -contentOffsetY);
            pageMainChildren.push(offsetNode);
        }

        // Create page node (y=0 for PDF parity)
        const page = createPageNode(
            pageIndex,
            pageMainChildren,
            paper,
            mainFrame,
            firstPage,
            frames,
            mainContainer,
            opts.repeatSidebarOnAllPages
        );
        pages.push(page);

        // Record split point (in original content space)
        if (endIndex < candidates.length - 1) {
            splitPoints.push(splitY);
            console.log(`[NEXAL2 Pagination] Page ${pageIndex + 1} split at Y=${splitY.toFixed(1)}pt, items ${startIndex}-${endIndex}`);
        }

        // Move to next page
        contentOffsetY = splitY;
        startIndex = endIndex + 1;
        pageIndex++;
    }

    return {
        pages,
        pageCount: pages.length,
        didPaginate: pages.length > 1,
        splitPoints,
        warnings,
    };
}

/**
 * Phase 4.8: Find the best split point using scoring.
 */
function findBestPageEnd(
    candidates: SplitCandidate[],
    startIndex: number,
    contentOffsetY: number,
    availableHeight: number,
    opts: Required<PaginationOptions>
): { endIndex: number; splitY: number; pageWarnings: PaginationWarning[] } {
    const pageWarnings: PaginationWarning[] = [];

    // First pass: find all candidates that fit on this page
    const fittingIndices: number[] = [];

    for (let i = startIndex; i < candidates.length; i++) {
        const candidate = candidates[i];
        const relativeEndY = candidate.endY - contentOffsetY;

        if (relativeEndY <= availableHeight) {
            fittingIndices.push(i);
        } else {
            break;
        }
    }

    // Handle oversized item (nothing fits)
    const startCandidate = candidates[startIndex];
    const startRelativeEndY = startCandidate.endY - contentOffsetY;

    if (fittingIndices.length === 0 || (fittingIndices.length === 1 && fittingIndices[0] === startIndex && startRelativeEndY > availableHeight)) {
        // Oversized item - emit warning and place alone
        const warning: PaginationWarning = {
            code: 'OVERSIZED_BLOCK',
            nodeId: startCandidate.node.nodeId,
            nodeType: startCandidate.node.nodeType,
            message: `Oversized block: ${startCandidate.node.nodeId} (${startCandidate.node.frame.height.toFixed(1)}pt > ${availableHeight.toFixed(1)}pt)`,
            data: {
                height: startCandidate.node.frame.height,
                availableHeight,
            },
        };
        pageWarnings.push(warning);
        console.warn(`[NEXAL2 Pagination] ${warning.code}: ${warning.message}`);

        return {
            endIndex: startIndex,
            splitY: startCandidate.endY,
            pageWarnings,
        };
    }

    // If everything fits, return the last candidate
    const lastFitIndex = fittingIndices[fittingIndices.length - 1];
    if (lastFitIndex === candidates.length - 1) {
        return {
            endIndex: lastFitIndex,
            splitY: candidates[lastFitIndex].endY,
            pageWarnings,
        };
    }

    // Phase 4.8: Score each candidate split point
    let bestScore = -Infinity;
    let bestSplitIndex = lastFitIndex;

    for (const splitIndex of fittingIndices) {
        const score = scoreSplitPoint(candidates, splitIndex, startIndex, lastFitIndex, opts);
        if (score > bestScore) {
            bestScore = score;
            bestSplitIndex = splitIndex;
        }
    }

    // Check if the chosen split leaves a lonely title at bottom
    const splitCandidate = candidates[bestSplitIndex];
    if (splitCandidate.keepRule === 'keepWithNext') {
        // Would leave title alone - check if we can move it to next page
        if (bestSplitIndex > startIndex) {
            bestSplitIndex = bestSplitIndex - 1;
            pageWarnings.push({
                code: 'ORPHAN_TITLE',
                nodeId: splitCandidate.node.nodeId,
                nodeType: splitCandidate.node.nodeType,
                message: `Moved title to next page to prevent orphan: ${splitCandidate.node.nodeId}`,
            });
            console.log(`[NEXAL2 Pagination] Orphan prevention: moved ${splitCandidate.node.nodeId} to next page`);
        }
    }

    // Apply widow rule
    const remainingItems = candidates.length - bestSplitIndex - 1;
    if (remainingItems < opts.minWidows && bestSplitIndex > startIndex) {
        bestSplitIndex = Math.max(startIndex, bestSplitIndex - (opts.minWidows - remainingItems));
        console.log(`[NEXAL2 Pagination] Widow prevention: adjusted split to index ${bestSplitIndex}`);
    }

    return {
        endIndex: bestSplitIndex,
        splitY: candidates[bestSplitIndex].endY,
        pageWarnings,
    };
}

/**
 * Phase 4.8: Score a candidate split point.
 */
function scoreSplitPoint(
    candidates: SplitCandidate[],
    splitIndex: number,
    startIndex: number,
    lastFitIndex: number,
    opts: Required<PaginationOptions>
): number {
    let score = 0;
    const splitCandidate = candidates[splitIndex];
    const nextCandidate = candidates[splitIndex + 1];

    // Boost: splitting after a complete section
    if (splitCandidate.isSection) {
        score += SCORE_AFTER_SECTION;
    }

    // Boost: splitting after a list/block structure (use fieldPath when available)
    const fp = splitCandidate.node.fieldPath || '';
    if (splitCandidate.node.nodeType === 'list' || fp.includes('.tasks') || fp.includes('[].tasks')) {
        score += SCORE_AFTER_LIST_BLOCK;
    }

    // Penalty: violating keepWithNext (splitting right after a title)
    if (splitCandidate.keepRule === 'keepWithNext') {
        score += PENALTY_KEEP_WITH_NEXT;
    }

    // Penalty: breaking a keepTogether group
    if (splitCandidate.keepRule === 'keepTogether') {
        // Check if there are related items after this that would be split
        const itemsAfterInGroup = countRelatedItems(candidates, splitIndex);
        if (itemsAfterInGroup > 0 && itemsAfterInGroup < opts.keepTogetherThreshold) {
            score += PENALTY_KEEP_TOGETHER;
        }
    }

    // Penalty: lonely title (title is last item on page)
    if (splitCandidate.isSectionTitle) {
        score += PENALTY_LONELY_TITLE;
    }

    // Penalty: nextCandidate is a continuation (part of same group)
    if (nextCandidate && isContinuation(splitCandidate, nextCandidate)) {
        score += PENALTY_KEEP_TOGETHER / 2;
    }

    return score;
}

/**
 * Count items related to the current item (same parent fieldPath or nodeId prefix).
 * Phase 4.9: Prefers fieldPath when available.
 */
function countRelatedItems(candidates: SplitCandidate[], fromIndex: number): number {
    let count = 0;
    const currentNode = candidates[fromIndex].node;

    // Use fieldPath when available, fallback to nodeId
    const currentPath = currentNode.fieldPath || currentNode.nodeId;
    const prefix = getFieldPathPrefix(currentPath);

    for (let i = fromIndex + 1; i < candidates.length; i++) {
        const candidatePath = candidates[i].node.fieldPath || candidates[i].node.nodeId;
        const candidatePrefix = getFieldPathPrefix(candidatePath);
        if (candidatePrefix === prefix) {
            count++;
        } else {
            break;
        }
    }

    return count;
}

/**
 * Get the parent prefix from a fieldPath or nodeId.
 * E.g., 'experiences[0].tasks' -> 'experiences[0]'
 *       'experience.0.tasks' -> 'experience.0'
 */
function getFieldPathPrefix(path: string): string {
    // Handle array notation: experiences[0].tasks -> experiences[0]
    const bracketMatch = path.match(/^(.+\[\d+\])/);
    if (bracketMatch) return bracketMatch[1];

    // Handle dot notation: experience.0.tasks -> experience.0
    const parts = path.split('.');
    return parts.length >= 2 ? parts.slice(0, 2).join('.') : path;
}

/**
 * Check if nextCandidate is a continuation of currentCandidate (same group).
 * Phase 4.9: Prefers fieldPath when available.
 */
function isContinuation(current: SplitCandidate, next: SplitCandidate): boolean {
    const currentPath = current.node.fieldPath || current.node.nodeId;
    const nextPath = next.node.fieldPath || next.node.nodeId;

    const currentPrefix = getFieldPathPrefix(currentPath);
    const nextPrefix = getFieldPathPrefix(nextPath);

    return currentPrefix === nextPrefix && currentPrefix !== '';
}

/**
 * Clone a node with adjusted Y offset.
 */
function cloneWithOffsetY(node: LayoutNode, offsetY: number): LayoutNode {
    return {
        ...node,
        frame: {
            ...node.frame,
            y: node.frame.y + offsetY,
        },
        children: node.children?.map(child => cloneWithOffsetY(child, 0)),
    };
}

/**
 * Create a page node with the given children in main container.
 * 
 * Phase 4.6: page.frame.y = 0 (local coordinates) for PDF parity.
 * The pageIndex is used for node ID and HTML vertical stacking only.
 * P0 Fix: repeatSidebarOnAllPages controls whether sidebar appears on subsequent pages.
 */
function createPageNode(
    pageIndex: number,
    mainChildren: LayoutNode[],
    paper: { width: number; height: number },
    mainFrame: LayoutFrame,
    firstPage: LayoutNode,
    frames: any,
    _mainContainer: LayoutNode,
    repeatSidebarOnAllPages: boolean = false
): LayoutNode {
    // Phase 4.6: Each page uses local coordinates (y=0)
    // HTML renderer will stack pages vertically using page index

    // Clone containers from first page, replacing main's children
    const pageChildren: LayoutNode[] = [];

    for (const container of firstPage.children || []) {
        if (container.nodeId === 'main') {
            // Main container with paginated children
            pageChildren.push({
                ...container,
                frame: { ...mainFrame }, // Use original main frame position
                children: mainChildren,
            });
        } else if (container.nodeId === 'sidebar' && frames?.sidebar) {
            // P0 FIX: Sidebar only on first page unless repeatSidebarOnAllPages is true
            if (pageIndex === 0 || repeatSidebarOnAllPages) {
                // Deep clone sidebar to prevent shared references
                pageChildren.push(deepCloneNode(container));
            }
        } else if (container.nodeId.startsWith('header') && pageIndex === 0) {
            // Header only on first page
            pageChildren.push(deepCloneNode(container));
        } else if (container.nodeId.startsWith('leftRail') || container.nodeId.startsWith('rightRail')) {
            // Rails: same logic as sidebar
            if (pageIndex === 0 || repeatSidebarOnAllPages) {
                pageChildren.push(deepCloneNode(container));
            }
        }
    }

    return {
        nodeId: `page-${pageIndex + 1}`,
        nodeType: 'page',
        frame: {
            x: 0,
            y: 0, // Phase 4.6: Local coords (y=0) for PDF parity
            width: paper.width,
            height: paper.height,
        },
        children: pageChildren,
        computedStyle: firstPage.computedStyle,
    };
}

/**
 * P0 FIX: Deep clone a layout node to prevent shared references causing double rendering.
 */
function deepCloneNode(node: LayoutNode): LayoutNode {
    return {
        ...node,
        frame: { ...node.frame },
        computedStyle: { ...node.computedStyle },
        children: node.children?.map(child => deepCloneNode(child)),
    };
}

// ============================================================================
// PHASE 4.9: PARITY SIGNATURES
// ============================================================================

/**
 * Phase 4.9: Compute a parity signature for a page.
 * Hash of [nodeId, rounded x/y/w/h, nodeType] for all nodes.
 * Phase 5.5: Sort children deterministically to ensure stable signatures
 * regardless of internal construction order.
 */
function computePageSignature(page: LayoutNode): string {
    const parts: string[] = [];

    function walk(node: LayoutNode): void {
        // Phase 5.5: Round frames to integers for stable signatures across runs
        const x = Math.round(node.frame.x);
        const y = Math.round(node.frame.y);
        const w = Math.round(node.frame.width);
        const h = Math.round(node.frame.height);

        // Phase 4.9: Prefer fieldPath over nodeId for stability
        const identifier = node.fieldPath || node.nodeId;
        parts.push(`${node.nodeType}|${identifier}|${x},${y},${w},${h}`);

        // Phase 5.5: Sort children deterministically before traversal
        // This ensures signatures are stable regardless of internal node ordering
        if (node.children && node.children.length > 0) {
            const sortedChildren = [...node.children].sort((a, b) => {
                const idA = a.fieldPath || a.nodeId;
                const idB = b.fieldPath || b.nodeId;
                const axR = Math.round(a.frame.x), ayR = Math.round(a.frame.y);
                const awR = Math.round(a.frame.width), ahR = Math.round(a.frame.height);
                const bxR = Math.round(b.frame.x), byR = Math.round(b.frame.y);
                const bwR = Math.round(b.frame.width), bhR = Math.round(b.frame.height);

                return (
                    a.nodeType.localeCompare(b.nodeType) ||
                    idA.localeCompare(idB) ||
                    (axR - bxR) || (ayR - byR) || (awR - bwR) || (ahR - bhR)
                );
            });
            sortedChildren.forEach(walk);
        }
    }

    walk(page);

    // Simple hash: FNV-1a style
    let hash = 2166136261;
    const str = parts.join(';');
    for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = ((hash * 16777619) >>> 0); // Force unsigned 32-bit
    }

    return hash.toString(16).padStart(8, '0');
}

// ============================================================================
// EXPORTS
// ============================================================================

export default paginateLayout;
</file>

<file path="renderers/html/EditableHTMLRenderer.tsx">
/**
 * Phase 7.0 - Editable HTML Renderer
 * 
 * Wrapper around HTMLRenderer that adds inline editing support.
 * Uses event delegation for click handling.
 * 
 * FRR: isInlineEditEnabled prop guards edit mode (default: true for backwards compat)
 */

import React, { useState, useCallback, useRef } from 'react';
import HTMLRenderer from './HTMLRenderer';
import { InlineEditOverlay } from '../../editing/InlineEditOverlay';
import { applyFieldPatch, getFieldValue, isFieldEditable } from '../../editing/applyFieldPatch';
import { useCVStoreV2 } from '../../../application/store/v2/cv-store-v2';
import type { LayoutTree } from '../../types';

export interface EditableHTMLRendererProps {
    layout: LayoutTree;
    scale?: number;
    debug?: boolean;
    layoutSignature?: string;
    margins?: { top: number; right: number; bottom: number; left: number };
    /** FRR: Enable/disable inline editing. Default: true */
    isInlineEditEnabled?: boolean;
}

interface EditState {
    isOpen: boolean;
    fieldPath: string;
    nodeId: string;
    initialValue: string;
    position: { top: number; left: number };
}

const initialEditState: EditState = {
    isOpen: false,
    fieldPath: '',
    nodeId: '',
    initialValue: '',
    position: { top: 0, left: 0 },
};

/**
 * Editable HTML Renderer with inline editing support.
 */
export const EditableHTMLRenderer: React.FC<EditableHTMLRendererProps> = ({
    layout,
    scale = 1,
    debug = false,
    layoutSignature,
    margins,
    isInlineEditEnabled = true, // FRR: Default enabled for dev, can be disabled for clean preview
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [editState, setEditState] = useState<EditState>(initialEditState);

    // Store access
    const profile = useCVStoreV2((state) => state.profile);
    const updateField = useCVStoreV2((state) => state.updateField);

    // Handle click on editable node (event delegation)
    const handleClick = useCallback((e: React.MouseEvent) => {
        // FRR: Guard - only handle if editing is enabled
        if (!isInlineEditEnabled) return;

        const target = e.target as HTMLElement;

        // Find closest element with data-field-path
        const editableEl = target.closest('[data-field-path]') as HTMLElement | null;
        if (!editableEl) return;

        const fieldPath = editableEl.getAttribute('data-field-path');
        const nodeId = editableEl.getAttribute('data-node-id') || '';

        // Check if editable
        if (!fieldPath || !isFieldEditable(fieldPath)) {
            return;
        }

        // Get current value
        const currentValue = getFieldValue(profile, fieldPath);

        // Position overlay near clicked element (uses viewport coords via getBoundingClientRect)
        const rect = editableEl.getBoundingClientRect();
        const position = {
            top: Math.min(rect.bottom + 4, window.innerHeight - 200),
            left: Math.min(rect.left, window.innerWidth - 320),
        };

        setEditState({
            isOpen: true,
            fieldPath,
            nodeId,
            initialValue: currentValue,
            position,
        });
    }, [profile, isInlineEditEnabled]);

    // Handle save
    const handleSave = useCallback((fieldPath: string, value: string) => {
        applyFieldPatch({ updateField }, fieldPath, value);
        setEditState(initialEditState);
    }, [updateField]);

    // Handle cancel
    const handleCancel = useCallback(() => {
        setEditState(initialEditState);
    }, []);

    return (
        <div
            ref={containerRef}
            onClick={handleClick}
            style={{
                position: 'relative',
                // FRR: Visual indicator when edit mode is enabled
                cursor: isInlineEditEnabled ? 'default' : undefined,
            }}
        >
            <HTMLRenderer
                layout={layout}
                scale={scale}
                debug={debug}
                layoutSignature={layoutSignature}
                margins={margins}
            />

            {isInlineEditEnabled && (
                <InlineEditOverlay
                    isOpen={editState.isOpen}
                    fieldPath={editState.fieldPath}
                    nodeId={editState.nodeId}
                    initialValue={editState.initialValue}
                    position={editState.position}
                    onSave={handleSave}
                    onCancel={handleCancel}
                />
            )}
        </div>
    );
};

export default EditableHTMLRenderer;
</file>

<file path="renderers/html/HTMLRenderer.tsx">
/**
 * NEXAL2 - HTML Renderer
 *
 * Renders a LayoutTree as absolute-positioned HTML elements.
 * NO CSS flexbox/grid - all layout is pre-computed.
 *
 * Phase 2.3: Uses nodeType instead of nodeId heuristics.
 * Phase 2.4: PT_TO_PX conversion for HTML/PDF parity.
 * Phase 4.1: Edge-snapping to eliminate pixel gaps between adjacent frames.
 * Phase 4.2: Floor/ceil snapping for bulletproof edge alignment.
 */

import React from 'react';
import type { LayoutTree, LayoutNode } from '../../types';
import { isFieldEditable } from '../../editing/applyFieldPatch';

// ============================================================================
// UNIT CONVERSION: Points to CSS Pixels
// ============================================================================

/**
 * 1 point = 1/72 inch
 * CSS pixel = 1/96 inch (at standard 96dpi)
 * Therefore: 1pt = 96/72 px = 1.3333... px
 */
const PT_TO_PX = 96 / 72;

interface HTMLRendererProps {
    layout: LayoutTree;
    scale?: number;
    debug?: boolean;
    layoutSignature?: string;
    /** Margins for page number positioning (from constraints) */
    margins?: { top: number; right: number; bottom: number; left: number };
}

/**
 * Render a LayoutTree as HTML using absolute positioning.
 * Applies PT_TO_PX conversion with edge-snapping for pixel-perfect rendering.
 */
export const HTMLRenderer: React.FC<HTMLRendererProps> = ({
    layout,
    scale = 1,
    debug = false,
    layoutSignature,
    margins = { top: 40, right: 40, bottom: 40, left: 40 },
}) => {
    const { bounds, pages } = layout;

    // Convert PT to raw PX (no rounding)
    const toPx = (pt: number) => pt * scale * PT_TO_PX;

    // Container dimensions: use ceil to ensure we don't clip content
    const containerWidth = Math.ceil(toPx(bounds.width));

    // Single page height (for multi-page stacking)
    const pageCount = pages.length;
    const singlePageHeight = pageCount > 0
        ? Math.ceil(toPx(pages[0].frame.height))
        : Math.ceil(toPx(bounds.height));

    // CRITICAL FIX: Container height must account for ALL pages, not just bounds.height
    // For multi-page layouts, stack pages vertically
    const containerHeight = pageCount > 1
        ? singlePageHeight * pageCount
        : Math.ceil(toPx(bounds.height));

    return (
        <div
            style={{
                position: 'relative',
                width: containerWidth,
                height: containerHeight,
                backgroundColor: '#FFFFFF',
                overflow: 'hidden',
                transformOrigin: 'top left',
            }}
        >
            {pages.map((page, pageIndex) => {
                // Phase 4.6: Stack pages vertically using index
                // Each page has frame.y=0 (local coords), we offset by pageIndex * pageHeight
                const pageTopY = pageIndex * singlePageHeight;

                return (
                    <div
                        key={page.nodeId}
                        style={{
                            position: 'absolute',
                            left: 0,
                            top: pageTopY,
                            width: Math.ceil(toPx(page.frame.width)),
                            height: singlePageHeight,
                            // Add subtle page separator for multi-page
                            borderBottom: pageIndex < pageCount - 1 ? '1px solid #e5e7eb' : undefined,
                        }}
                    >
                        {renderLayoutNode(page, scale, debug, page.frame.width, page.frame.height)}

                        {/* Phase 4.7: Page numbers for multi-page layouts */}
                        {pageCount > 1 && (
                            <div
                                style={{
                                    position: 'absolute',
                                    bottom: Math.ceil(toPx(margins.bottom / 2)),
                                    right: Math.ceil(toPx(margins.right)),
                                    fontSize: Math.ceil(toPx(8)),
                                    color: '#9CA3AF',
                                    fontFamily: 'Helvetica, Arial, sans-serif',
                                }}
                            >
                                {pageIndex + 1} / {pageCount}
                            </div>
                        )}
                    </div>
                );
            })}
            {/* Signature overlay (bottom-right) */}
            {layoutSignature && (
                <div
                    style={{
                        position: 'absolute',
                        right: 8,
                        bottom: 8,
                        fontSize: 8,
                        color: '#999999',
                        fontFamily: 'Helvetica, Arial, sans-serif',
                    }}
                >
                    NEXAL2 Sig: {layoutSignature}
                </div>
            )}
        </div>
    );
};

/**
 * SVG Placeholder Icon for photo (no emoji dependency)
 * Size is snapped to integer pixels.
 */
const PhotoPlaceholderSVG: React.FC<{ size: number; scale: number }> = ({ size, scale }) => {
    const pxSize = Math.round(size * scale * PT_TO_PX);
    return (
        <svg
            width={pxSize}
            height={pxSize}
            viewBox="0 0 80 80"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
        >
            <circle cx="40" cy="40" r="38" fill="#E5E7EB" stroke="#D1D5DB" strokeWidth="2" />
            <circle cx="40" cy="32" r="12" fill="#9CA3AF" />
            <ellipse cx="40" cy="60" rx="20" ry="14" fill="#9CA3AF" />
        </svg>
    );
};

// ============================================================================
// EDGE-SNAPPING HELPERS (Phase 4.2: Floor/Ceil for bulletproof edges)
// ============================================================================

/**
 * Convert PT to PX with scale (raw, not snapped).
 * Used for fontSize and other non-positional values.
 */
function pxRaw(pt: number, scale: number): number {
    return pt * scale * PT_TO_PX;
}

// Epsilon for edge detection (0.5pt tolerance)
const EDGE_EPSILON_PT = 0.5;

/**
 * Edge-snap a frame to integer pixels using floor/ceil strategy.
 * - Left edge: floor (ensures content starts at or after intended position)
 * - Right edge: ceil if flush to paper edge, else floor+width
 * - Top edge: floor
 * - Bottom edge: ceil if flush to paper edge, else floor+height
 * 
 * This eliminates gaps for elements that should touch paper edges.
 */
function snapFrameEdges(
    frame: { x: number; y: number; width: number; height: number },
    scale: number,
    paperWidthPt: number,
    paperHeightPt: number
): { left: number; top: number; width: number; height: number; useRightAnchor: boolean; useBottomAnchor: boolean } {
    const toPx = (pt: number) => pt * scale * PT_TO_PX;

    // Raw pixel positions
    const leftRaw = toPx(frame.x);
    const topRaw = toPx(frame.y);
    const rightRaw = toPx(frame.x + frame.width);
    const bottomRaw = toPx(frame.y + frame.height);

    // Check if edges touch paper boundaries
    const isFlushLeft = frame.x < EDGE_EPSILON_PT;
    const isFlushTop = frame.y < EDGE_EPSILON_PT;
    const isFlushRight = Math.abs((frame.x + frame.width) - paperWidthPt) < EDGE_EPSILON_PT;
    const isFlushBottom = Math.abs((frame.y + frame.height) - paperHeightPt) < EDGE_EPSILON_PT;

    // Snap edges: floor for left/top, ceil for flush right/bottom
    const left = isFlushLeft ? 0 : Math.floor(leftRaw);
    const top = isFlushTop ? 0 : Math.floor(topRaw);

    // For right edge: if flush, use ceil to ensure we reach the container edge
    // For non-flush, use consistent rounding
    const right = isFlushRight ? Math.ceil(toPx(paperWidthPt)) : Math.ceil(rightRaw);
    const bottom = isFlushBottom ? Math.ceil(toPx(paperHeightPt)) : Math.ceil(bottomRaw);

    return {
        left,
        top,
        width: right - left,
        height: bottom - top,
        useRightAnchor: isFlushRight,
        useBottomAnchor: isFlushBottom,
    };
}

/**
 * Recursively render a LayoutNode and its children.
 * Uses nodeType for branching (no heuristics).
 * Applies edge-snapping for pixel-perfect rendering.
 */
function renderLayoutNode(
    node: LayoutNode,
    scale: number,
    debug: boolean,
    paperWidthPt: number,
    paperHeightPt: number
): React.ReactNode {
    const { frame, computedStyle, content, children, nodeId, nodeType } = node;

    // Edge-snap the frame for pixel-perfect positioning
    const snapped = snapFrameEdges(frame, scale, paperWidthPt, paperHeightPt);

    // Base styles for all nodes (edge-snapped)
    // If element is flush right, use right: 0 instead of width for bulletproof alignment
    const baseStyle: React.CSSProperties = snapped.useRightAnchor ? {
        position: 'absolute',
        left: snapped.left,
        top: snapped.top,
        right: 0, // Use right anchor for flush-right elements
        height: snapped.height,
        boxSizing: 'border-box',
        overflow: 'hidden',
    } : {
        position: 'absolute',
        left: snapped.left,
        top: snapped.top,
        width: snapped.width,
        height: snapped.height,
        boxSizing: 'border-box',
        overflow: 'hidden',
    };

    // Debug mode: show borders
    if (debug) {
        baseStyle.border = '1px dashed rgba(255, 0, 0, 0.3)';
    }

    // Branch on nodeType (NOT nodeId heuristics)
    switch (nodeType) {
        case 'image': {
            // Render image node (photo with SVG placeholder)
            const isPlaceholder = content === 'PLACEHOLDER_PHOTO' || !content;
            return (
                <div
                    key={nodeId}
                    style={{
                        ...baseStyle,
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                    }}
                    data-node={nodeId}
                >
                    {isPlaceholder ? (
                        <PhotoPlaceholderSVG size={frame.width} scale={scale} />
                    ) : (
                        <img
                            src={content}
                            alt="Photo"
                            style={{
                                width: '100%',
                                height: '100%',
                                objectFit: 'cover',
                                borderRadius: '50%',
                            }}
                        />
                    )}
                </div>
            );
        }

        case 'listItem': {
            // Render list item with bullet prefix
            const fontSize = pxRaw(computedStyle.fontSize, scale);
            const lineHeightPx = computedStyle.fontSize * computedStyle.lineHeight * scale * PT_TO_PX;
            return (
                <div
                    data-field-path={node.fieldPath}
                    data-node-id={nodeId}
                    style={{
                        ...baseStyle,
                        fontSize,
                        lineHeight: `${lineHeightPx}px`,
                        color: computedStyle.color,
                        fontWeight: computedStyle.fontWeight,
                        fontFamily: computedStyle.fontFamily,
                        letterSpacing: computedStyle.letterSpacing ? pxRaw(computedStyle.letterSpacing, scale) : undefined,
                        display: 'flex',
                        alignItems: 'flex-start',
                        overflow: 'visible',
                        cursor: isFieldEditable(node.fieldPath) ? 'pointer' : undefined,
                    }}
                >
                    <span style={{ marginRight: pxRaw(4, scale), flexShrink: 0 }}>â€¢</span>
                    <span style={{
                        whiteSpace: 'pre-wrap',
                        overflowWrap: 'anywhere',
                        wordBreak: 'break-word',
                    }}>{content}</span>
                </div>
            );
        }

        case 'text': {
            // Render text node
            const fontSize = pxRaw(computedStyle.fontSize, scale);
            const lineHeightPx = computedStyle.fontSize * computedStyle.lineHeight * scale * PT_TO_PX;
            const textStyle: React.CSSProperties = {
                ...baseStyle,
                fontSize,
                lineHeight: `${lineHeightPx}px`,
                color: computedStyle.color,
                backgroundColor: computedStyle.backgroundColor,
                fontWeight: computedStyle.fontWeight,
                fontFamily: computedStyle.fontFamily,
                textAlign: computedStyle.textAlign,
                textTransform: computedStyle.textTransform,
                letterSpacing: computedStyle.letterSpacing ? pxRaw(computedStyle.letterSpacing, scale) : undefined,
                // Word-break properties for PDF parity
                whiteSpace: 'pre-wrap',
                overflowWrap: 'anywhere',
                wordBreak: 'break-word',
                overflow: 'visible',
            };

            return (
                <div
                    key={nodeId}
                    style={{
                        ...textStyle,
                        cursor: isFieldEditable(node.fieldPath) ? 'pointer' : undefined,
                    }}
                    data-field-path={node.fieldPath}
                    data-node-id={nodeId}
                >
                    {content}
                </div>
            );
        }

        // Container types: page, document, container, section, list, spacer
        default: {
            return (
                <div
                    key={nodeId}
                    style={{
                        ...baseStyle,
                        backgroundColor: computedStyle.backgroundColor,
                    }}
                    data-field-path={node.fieldPath}
                    data-node-id={nodeId}
                >
                    {children?.map((child) => renderLayoutNode(child, scale, debug, paperWidthPt, paperHeightPt))}
                </div>
            );
        }
    }
}

export default HTMLRenderer;
</file>

<file path="renderers/html/index.ts">
/**
 * NEXAL2 - HTML Renderer Module
 */

export { HTMLRenderer } from './HTMLRenderer';
export { EditableHTMLRenderer } from './EditableHTMLRenderer';
</file>

<file path="renderers/pdf/index.ts">
/**
 * NEXAL2 - PDF Renderer Module
 */

export { PDFRenderer } from './PDFRenderer';
</file>

<file path="renderers/pdf/PDFRenderer.tsx">
/**
 * NEXAL2 - PDF Renderer
 *
 * Renders a LayoutTree using @react-pdf/renderer.
 * All elements absolutely positioned - no flexbox auto.
 *
 * Phase 2.3: Uses nodeType instead of nodeId heuristics.
 * Uses SVG placeholder for photos (no emoji dependency).
 */

import React from 'react';
import { Document, Page, View, Text, Image, StyleSheet, Svg, Circle, Path } from '@react-pdf/renderer';
import type { LayoutTree, LayoutNode } from '../../types';

interface PDFRendererProps {
    layout: LayoutTree;
    title?: string;
    layoutSignature?: string;
    /** Margins for page number positioning (from constraints) */
    margins?: { top: number; right: number; bottom: number; left: number };
}

/**
 * Render a LayoutTree as a PDF document.
 * Phase 4.7: Added page numbers for multi-page layouts.
 */
export const PDFRenderer: React.FC<PDFRendererProps> = ({
    layout,
    title = 'CV',
    layoutSignature,
    margins = { top: 40, right: 40, bottom: 40, left: 40 },
}) => {
    const { pages } = layout;
    const pageCount = pages.length;

    // Use first page dimensions (all pages should be same size)
    const pageWidth = pages[0]?.frame.width || layout.bounds.width;
    const pageHeight = pages[0]?.frame.height || layout.bounds.height;

    // Dynamic page number styles based on margins
    const pageNumberStyle = {
        position: 'absolute' as const,
        bottom: margins.bottom / 2,
        right: margins.right,
    };
    const pageNumberTextStyle = {
        fontSize: 8,
        color: '#9CA3AF',
        fontFamily: 'Helvetica' as const,
    };

    return (
        <Document title={title}>
            {pages.map((page, pageIndex) => (
                <Page
                    key={page.nodeId}
                    size={{ width: pageWidth, height: pageHeight }}
                    style={styles.page}
                >
                    {renderPDFNode(page)}

                    {/* Phase 4.7: Page numbers for multi-page layouts */}
                    {pageCount > 1 && (
                        <View style={pageNumberStyle}>
                            <Text style={pageNumberTextStyle}>
                                {pageIndex + 1} / {pageCount}
                            </Text>
                        </View>
                    )}

                    {/* Layout signature footer for parity proof */}
                    {layoutSignature && (
                        <View style={styles.footer}>
                            <Text style={styles.footerText}>
                                NEXAL2 Sig: {layoutSignature}
                            </Text>
                        </View>
                    )}
                </Page>
            ))}
        </Document>
    );
};


/**
 * SVG Placeholder for photo (matches HTML version).
 * Note: react-pdf doesn't support rgba() in fill, use fill + fillOpacity instead.
 */
const PhotoPlaceholderPDF: React.FC<{ size: number }> = ({ size }) => (
    <Svg width={size} height={size} viewBox="0 0 80 80">
        <Circle cx="40" cy="40" r="40" fill="#FFFFFF" fillOpacity={0.2} />
        <Circle cx="40" cy="30" r="14" fill="#FFFFFF" fillOpacity={0.5} />
        <Path
            d="M40 48C28 48 20 56 20 66C20 70 24 72 40 72C56 72 60 70 60 66C60 56 52 48 40 48Z"
            fill="#FFFFFF"
            fillOpacity={0.5}
        />
    </Svg>
);

/**
 * Apply text transform manually (react-pdf support may vary).
 */
function applyTextTransform(s: string | undefined, t: 'none' | 'uppercase' | undefined): string {
    if (!s) return '';
    switch (t) {
        case 'uppercase': return s.toUpperCase();
        default: return s;
    }
}

/**
 * Recursively render a LayoutNode for PDF.
 * Uses nodeType for branching (no heuristics).
 */
function renderPDFNode(node: LayoutNode): React.ReactNode {
    const { frame, computedStyle, content, children, nodeId, nodeType, fieldPath } = node;

    // Base style for all nodes
    const baseStyle = {
        position: 'absolute' as const,
        left: frame.x,
        top: frame.y,
        width: frame.width,
        height: frame.height,
    };

    // Base style for text nodes (no height to avoid clipping)
    const baseStyleText = {
        position: 'absolute' as const,
        left: frame.x,
        top: frame.y,
        width: frame.width,
        // no height - let text flow naturally
    };

    // Branch on nodeType (NOT nodeId heuristics)
    switch (nodeType) {
        case 'image': {
            // Render image node (photo with SVG placeholder)
            const isPlaceholder = content === 'PLACEHOLDER_PHOTO' || !content;
            return (
                <View key={nodeId} style={baseStyle}>
                    {isPlaceholder ? (
                        <PhotoPlaceholderPDF size={frame.width} />
                    ) : (
                        <Image
                            src={content}
                            style={{
                                width: frame.width,
                                height: frame.height,
                                borderRadius: frame.width / 2,
                                objectFit: 'cover',
                            }}
                        />
                    )}
                </View>
            );
        }

        case 'listItem': {
            // Render list item with bullet prefix
            const textStyle = {
                fontSize: computedStyle.fontSize,
                lineHeight: computedStyle.lineHeight, // multiplier for react-pdf
                color: computedStyle.color,
                fontWeight: computedStyle.fontWeight === 'bold' ? 700 : 400,
                fontFamily: mapPDFFontFamily(computedStyle.fontFamily),
                letterSpacing: computedStyle.letterSpacing,
            };

            const rendered = applyTextTransform(content, computedStyle.textTransform);

            return (
                <View key={nodeId} style={{
                    ...baseStyleText,
                    display: 'flex',
                    flexDirection: 'row',
                    alignItems: 'flex-start',
                }}>
                    <Text style={{ ...textStyle, marginRight: 4 }}>â€¢</Text>
                    <Text style={textStyle}>{rendered}</Text>
                </View>
            );
        }

        case 'text': {
            // Render text node
            const textStyle = {
                fontSize: computedStyle.fontSize,
                lineHeight: computedStyle.lineHeight, // multiplier for react-pdf
                color: computedStyle.color,
                fontWeight: computedStyle.fontWeight === 'bold' ? 700 : 400,
                fontFamily: mapPDFFontFamily(computedStyle.fontFamily),
                textAlign: computedStyle.textAlign as 'left' | 'center' | 'right',
                letterSpacing: computedStyle.letterSpacing,
            };

            const rendered = applyTextTransform(content, computedStyle.textTransform);

            return (
                <View key={nodeId} style={baseStyleText}>
                    <Text style={textStyle}>{rendered}</Text>
                </View>
            );
        }

        // Container types: page, document, container, section, list, spacer
        default: {
            return (
                <View key={nodeId} style={{
                    ...baseStyle,
                    backgroundColor: computedStyle.backgroundColor,
                }}>
                    {children?.map((child) => renderPDFNode(child))}
                </View>
            );
        }
    }
}

/**
 * Map font family to PDF-compatible font names.
 */
function mapPDFFontFamily(family: string): string {
    if (family.includes('serif') && !family.includes('sans')) {
        return 'Times-Roman';
    }
    if (family.includes('mono')) {
        return 'Courier';
    }
    return 'Helvetica';
}

const styles = StyleSheet.create({
    page: {
        position: 'relative',
        backgroundColor: '#FFFFFF',
    },
    footer: {
        position: 'absolute',
        bottom: 8,
        right: 8,
    },
    footerText: {
        fontSize: 6,
        color: '#999999',
        fontFamily: 'Helvetica',
    },
    // Phase 4.7: Page number styles
    pageNumber: {
        position: 'absolute',
        bottom: 20,
        right: 40,
    },
    pageNumberText: {
        fontSize: 8,
        color: '#9CA3AF',
        fontFamily: 'Helvetica',
    },
});

export default PDFRenderer;
</file>

<file path="scenegraph/buildScene.ts">
/**
 * NEXAL2 - SceneGraph Builder
 *
 * Transforms CVProfile + DesignConfig into a SceneDocument.
 * Pure function, no side effects.
 */

import type {
    SceneDocument,
    SceneNode,
    CVProfile,
    DesignConfig,
} from '../types';
import { getScaledTheme } from '../types';

// ============================================================================
// SPRINT 6.1: PRESET COVERAGE MAP (Single Source of Truth)
// ============================================================================
// Defines where each information block renders per preset.
// Rules: NO DUPLICATES - each block appears in exactly one container.

type ContainerType = 'sidebar' | 'header' | 'headerLeft' | 'headerRight' | 'main' | 'leftRail' | 'rightRail' | 'none';

interface PresetCoverage {
    identity: { container: ContainerType; includePhoto: boolean };
    contact: { container: ContainerType };
    skills: { container: ContainerType };
    languages: { container: ContainerType };
}

const PRESET_COVERAGE: Record<string, PresetCoverage> = {
    SIDEBAR: {
        identity: { container: 'sidebar', includePhoto: true },
        contact: { container: 'sidebar' },
        skills: { container: 'sidebar' },
        languages: { container: 'sidebar' },
    },
    TOP_HEADER: {
        identity: { container: 'header', includePhoto: true },
        contact: { container: 'header' }, // Contact line in header
        skills: { container: 'main' },
        languages: { container: 'main' },
    },
    SPLIT_HEADER: {
        identity: { container: 'headerLeft', includePhoto: false },
        contact: { container: 'headerRight' }, // Contact in headerRight alongside photo
        skills: { container: 'main' },
        languages: { container: 'main' },
    },
    LEFT_RAIL: {
        identity: { container: 'main', includePhoto: false },
        contact: { container: 'main' }, // Contact in main identity block
        skills: { container: 'leftRail' },
        languages: { container: 'main' },
    },
    DUAL_SIDEBAR: {
        identity: { container: 'main', includePhoto: false },
        contact: { container: 'rightRail' }, // Contact ONLY in rightRail (not main)
        skills: { container: 'leftRail' },
        languages: { container: 'rightRail' },
    },
    ATS_ONE_COLUMN: {
        identity: { container: 'main', includePhoto: false },
        contact: { container: 'main' }, // Contact in main identity block
        skills: { container: 'main' },
        languages: { container: 'main' },
    },
};

function getPresetCoverage(layoutPreset: string | undefined): PresetCoverage {
    return PRESET_COVERAGE[layoutPreset || 'SIDEBAR'] || PRESET_COVERAGE.SIDEBAR;
}

// ============================================================================
// PHASE 7.1: STRUCTURE MODE HELPERS
// ============================================================================

import {
    DEFAULT_STRUCTURE,
    type StructureConfig,
    type SectionId
} from '../../application/store/v2/cv-store-v2.types';

/** Get structure config with defaults */
function getStructure(design: any): StructureConfig {
    const s = design?.structure;
    return {
        order: s?.order || DEFAULT_STRUCTURE.order,
        visible: { ...DEFAULT_STRUCTURE.visible, ...s?.visible },
        limits: { ...DEFAULT_STRUCTURE.limits, ...s?.limits },
    };
}

/** Check if section is visible */
function isSectionVisible(structure: StructureConfig, sectionId: SectionId): boolean {
    return structure.visible[sectionId] !== false;
}

/**
 * Build a SceneDocument from profile and design configuration.
 *
 * @param profile - The CV profile data (accepts any object for testing)
 * @param design - The design configuration (accepts partial for testing)
 * @returns A complete SceneDocument ready for layout computation
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function buildScene(
    profile: any,
    design: any
): SceneDocument {
    const now = new Date().toISOString();
    const profileId = profile.id || 'unknown';
    const designHash = JSON.stringify(design).substring(0, 32);

    // Create page structure with all container types
    // computeLayout will only render containers that have matching frames
    const pageNode: SceneNode = {
        id: 'page-1',
        type: 'page',
        children: [
            // Classic sidebar (for SIDEBAR preset)
            createSidebarNode(profile, design),
            // Main content (all presets)
            createMainContentNode(profile, design),
            // Header (for TOP_HEADER preset)
            createHeaderNode(profile, design),
            // Split header (for SPLIT_HEADER preset)
            createHeaderLeftNode(profile, design),
            createHeaderRightNode(profile, design),
            // Rails (for LEFT_RAIL / DUAL_SIDEBAR presets)
            createLeftRailNode(profile, design),
            createRightRailNode(profile, design),
        ],
    };

    return {
        version: '1.0',
        paperFormat: design.paperFormat || 'A4',
        pageCount: 1,
        pages: [pageNode],
        metadata: {
            generatedAt: now,
            profileId,
            designHash,
        },
    };
}

/**
 * Create the sidebar container node.
 * Phase 5.3: Uses scaled theme for typography.
 */
function createSidebarNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const theme = getScaledTheme(design.photoScale ?? 2);
    const structure = getStructure(design);

    // Photo (if enabled - use placeholder if no URL)
    if (design.showPhoto) {
        // Use profile photo or a placeholder - Phase 5.4: Size from metrics
        const photoUrl = profile.personal?.photoUrl || 'PLACEHOLDER_PHOTO';
        const metrics = getPhotoScaleMetrics(design);
        children.push({
            id: 'sidebar.photo',
            type: 'image',
            content: photoUrl,
            fieldPath: 'personal.photoUrl',
            style: { width: metrics.photoSize, height: metrics.photoSize },
        });
    }

    // Name
    children.push({
        id: 'sidebar.name',
        type: 'text',
        content: `${profile.personal?.firstName || ''} ${profile.personal?.lastName || ''}`.trim(),
        fieldPath: 'personal.fullName', // Sprint 6.1: Correct fieldPath for full name
        style: { fontSize: theme.fontSize.name, fontWeight: 'bold', textAlign: 'center', color: '#FFFFFF' },
    });

    // Title
    if (profile.personal?.title) {
        children.push({
            id: 'sidebar.title',
            type: 'text',
            content: profile.personal.title,
            fieldPath: 'personal.title',
            style: { fontSize: theme.fontSize.title, textAlign: 'center', color: '#FFFFFF' },
        });
    }

    // Phase 5.3: Spacer after title for breathing room
    children.push({
        id: 'sidebar.spacer.afterTitle',
        type: 'spacer',
        style: { height: theme.spacing.itemMargin },
    });

    // Contact section - Phase 7.1: Check visibility
    if (isSectionVisible(structure, 'contact')) {
        const contactItems: SceneNode[] = [];
        if (profile.personal?.contact?.email) {
            contactItems.push({
                id: 'sidebar.contact.email',
                type: 'text',
                content: profile.personal.contact.email,
                fieldPath: 'personal.contact.email',
                style: { color: '#FFFFFF', fontSize: theme.fontSize.small },
            });
        }
        if (profile.personal?.contact?.phone) {
            contactItems.push({
                id: 'sidebar.contact.phone',
                type: 'text',
                content: profile.personal.contact.phone,
                fieldPath: 'personal.contact.phone',
                style: { color: '#FFFFFF', fontSize: theme.fontSize.small },
            });
        }

        if (contactItems.length > 0) {
            children.push({
                id: 'sidebar.contact',
                type: 'section',
                children: [
                    { id: 'sidebar.contact.title', type: 'text', content: 'Contact', style: { fontWeight: 'bold', textTransform: 'uppercase', color: '#FFFFFF', fontSize: theme.fontSize.sectionTitle } },
                    ...contactItems,
                ],
            });
        }
    }

    // Skills section - Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'skills') && profile.skills && profile.skills.length > 0) {
        children.push({
            id: 'sidebar.skills',
            type: 'section',
            children: [
                { id: 'sidebar.skills.title', type: 'text', content: 'CompÃ©tences', style: { fontWeight: 'bold', textTransform: 'uppercase', color: '#FFFFFF', fontSize: theme.fontSize.sectionTitle } },
                {
                    id: 'sidebar.skills.list',
                    type: 'list',
                    children: profile.skills.slice(0, structure.limits.skillsTopN).map((skill, i) => ({
                        id: `sidebar.skills.item-${i}`,
                        type: 'listItem' as const,
                        content: skill,
                        fieldPath: `skills[${i}]`,
                        style: { color: '#FFFFFF', fontSize: theme.fontSize.small },
                    })),
                },
            ],
        });
    }

    // Languages section - Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'languages') && profile.languages && profile.languages.length > 0) {
        children.push({
            id: 'sidebar.languages',
            type: 'section',
            children: [
                { id: 'sidebar.languages.title', type: 'text', content: 'Langues', style: { fontWeight: 'bold', textTransform: 'uppercase', color: '#FFFFFF', fontSize: theme.fontSize.sectionTitle } },
                ...profile.languages.slice(0, structure.limits.languagesTopN).map((lang, i) => ({
                    id: `sidebar.languages.item-${i}`,
                    type: 'text' as const,
                    content: `${lang.name} â€” ${lang.level}`,
                    fieldPath: `languages[${i}]`,
                    style: { color: '#FFFFFF', fontSize: theme.fontSize.small },
                })),
            ],
        });
    }

    return {
        id: 'sidebar',
        type: 'container',
        children,
        style: {
            // Background
            backgroundColor: design.accentColor || '#4F46E5',
            // Root typographic style (children inherit) - Phase 5.4: Scaled
            color: '#FFFFFF',
            fontFamily: 'sans',
            fontSize: theme.fontSize.body,
            lineHeight: 1.4,
            // Padding - Phase 5.4: Scaled from theme spacing
            paddingTop: theme.spacing.sectionMargin + 4,
            paddingBottom: theme.spacing.sectionMargin + 4,
            paddingLeft: theme.spacing.itemMargin + 6,
            paddingRight: theme.spacing.itemMargin + 6,
            // Phase 5.3: Center alignment for photo
            alignItems: 'center',
            gap: theme.spacing.itemMargin,
        },
    };
}

/**
 * Create the main content container node.
 * Phase 5.4: Uses scaled theme for typography.
 * Sprint 6.1: Uses PRESET_COVERAGE for identity/contact/skills/languages placement.
 */
function createMainContentNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const theme = getScaledTheme(design.photoScale ?? 2);
    const coverage = getPresetCoverage(design.layoutPreset);
    const structure = getStructure(design);

    // Sprint 6.1: Identity block when coverage.identity.container === 'main'
    // Phase 7.1: Check visibility
    if (isSectionVisible(structure, 'identity') && coverage.identity.container === 'main' && profile.personal) {
        const identityChildren: SceneNode[] = [];

        // Name (bold, larger) - Sprint 6.1: fieldPath = personal.fullName
        const fullName = `${profile.personal.firstName || ''} ${profile.personal.lastName || ''}`.trim();
        if (fullName) {
            identityChildren.push({
                id: 'main.identity.name',
                type: 'text',
                content: fullName,
                fieldPath: 'personal.fullName', // Sprint 6.1: Correct fieldPath
                style: { fontSize: theme.fontSize.name, fontWeight: 'bold', color: design.accentColor || '#2563EB' },
            });
        }

        // Title
        if (profile.personal.title) {
            identityChildren.push({
                id: 'main.identity.title',
                type: 'text',
                content: profile.personal.title,
                fieldPath: 'personal.title',
                style: { fontSize: theme.fontSize.title, color: '#4B5563' },
            });
        }

        // Sprint 6.1: Contact ONLY if coverage.contact.container === 'main'
        // This fixes DUAL_SIDEBAR duplicate (contact should only be in rightRail)
        if (coverage.contact.container === 'main') {
            const contactParts: string[] = [];
            if (profile.personal.contact?.email) contactParts.push(profile.personal.contact.email);
            if (profile.personal.contact?.phone) contactParts.push(profile.personal.contact.phone);
            const address = profile.personal.contact?.address as string | { city?: string } | undefined;
            if (address) {
                if (typeof address === 'string') {
                    contactParts.push(address);
                } else if (address.city) {
                    contactParts.push(address.city);
                }
            }

            if (contactParts.length > 0) {
                identityChildren.push({
                    id: 'main.identity.contact',
                    type: 'text',
                    content: contactParts.join(' â€¢ '),
                    fieldPath: 'personal.contact', // Sprint 6.1: Generic fieldPath for compound field
                    style: { fontSize: theme.fontSize.small, color: '#6B7280' },
                });
            }
        }

        if (identityChildren.length > 0) {
            children.push({
                id: 'main.identity',
                type: 'section',
                children: identityChildren,
            });
        }
    }

    // Summary/Profil section - Phase 7.1: Check visibility
    if (isSectionVisible(structure, 'summary') && profile.summary) {
        children.push({
            id: 'main.summary',
            type: 'section',
            children: [
                { id: 'main.summary.title', type: 'text', content: 'Profil', style: { fontWeight: 'bold', textTransform: 'uppercase', fontSize: theme.fontSize.sectionTitle } },
                { id: 'main.summary.content', type: 'text', content: profile.summary, fieldPath: 'summary', style: { fontSize: theme.fontSize.body } },
            ],
        });
    }

    // Sprint 6.1: Skills in main when coverage.skills.container === 'main'
    // Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'skills') && coverage.skills.container === 'main' && profile.skills && profile.skills.length > 0) {
        const skillItems = profile.skills.slice(0, structure.limits.skillsTopN).map((skill: any, i: number) => ({
            id: `main.skills.item-${i}`,
            type: 'listItem' as const,
            content: typeof skill === 'string' ? skill : (skill.name || ''),
            fieldPath: typeof skill === 'string' ? `skills[${i}]` : `skills[${i}].name`, // Sprint 6.1: Accurate fieldPath
            style: { fontSize: theme.fontSize.small },
        }));

        children.push({
            id: 'main.skills',
            type: 'section',
            children: [
                { id: 'main.skills.title', type: 'text', content: 'CompÃ©tences', style: { fontWeight: 'bold', textTransform: 'uppercase', fontSize: theme.fontSize.sectionTitle } },
                {
                    id: 'main.skills.list',
                    type: 'list',
                    children: skillItems,
                },
            ],
        });
    }

    // Sprint 6.1: Languages in main when coverage.languages.container === 'main'
    if (coverage.languages.container === 'main' && profile.languages && profile.languages.length > 0) {
        const langItems = profile.languages.slice(0, 6).map((lang: any, i: number) => ({
            id: `main.languages.item-${i}`,
            type: 'text' as const,
            content: `${lang.name || lang} ${lang.level ? `(${lang.level})` : ''}`.trim(),
            fieldPath: `languages[${i}]`, // Sprint 6.1: Combined display, single fieldPath
            style: { fontSize: theme.fontSize.small },
        }));

        children.push({
            id: 'main.languages',
            type: 'section',
            children: [
                { id: 'main.languages.title', type: 'text', content: 'Langues', style: { fontWeight: 'bold', textTransform: 'uppercase', fontSize: theme.fontSize.sectionTitle } },
                ...langItems,
            ],
        });
    }

    // Experience section (Phase 6: use normalizeExperienceDates)
    // Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'experiences') && profile.experiences && profile.experiences.length > 0) {
        const expItems: SceneNode[] = profile.experiences
            .filter(exp => exp.role || exp.company)
            .slice(0, structure.limits.experiencesTopN)
            .map((exp, i) => ({
                id: `main.experience.item-${i}`,
                type: 'container' as const,
                fieldPath: `experiences[${i}]`,
                children: [
                    // Role (bold, own line)
                    { id: `main.experience.item-${i}.role`, type: 'text' as const, content: exp.role || '', style: { fontWeight: 'bold', fontSize: theme.fontSize.body } },
                    // TASK C: Compact header - company left, dates right (row spaceBetween)
                    {
                        id: `main.experience.item-${i}.header`,
                        type: 'container' as const,
                        style: { direction: 'row', justifyContent: 'spaceBetween', alignItems: 'center' },
                        children: [
                            { id: `main.experience.item-${i}.company`, type: 'text' as const, content: exp.company || '', style: { fontSize: theme.fontSize.body, color: '#4B5563' } },
                            { id: `main.experience.item-${i}.dates`, type: 'text' as const, content: normalizeExperienceDates(exp), style: { fontSize: theme.fontSize.small, color: '#6B7280' } },
                        ],
                    },
                    ...(exp.tasks || []).slice(0, structure.limits.tasksTopN).map((task, j) => ({
                        id: `main.experience.item-${i}.task-${j}`,
                        type: 'listItem' as const,
                        content: task,
                        style: { fontSize: theme.fontSize.body },
                    })),
                ],
            }));

        children.push({
            id: 'main.experience',
            type: 'section',
            children: [
                { id: 'main.experience.title', type: 'text', content: 'ExpÃ©rience Professionnelle', style: { fontWeight: 'bold', textTransform: 'uppercase', fontSize: theme.fontSize.sectionTitle } },
                ...expItems,
            ],
        });
    }

    // Education section
    // Sprint 6.2: Relaxed filter - keep entries with ANY meaningful field (degree, school, or year)
    // Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'educations') && profile.educations && profile.educations.length > 0) {
        const eduItems: SceneNode[] = profile.educations
            .filter(edu =>
                (edu.degree && edu.degree.trim()) ||
                (edu.school && edu.school.trim()) ||
                (edu.year && String(edu.year).trim())
            )
            .slice(0, structure.limits.educationsTopN)
            .map((edu, i) => ({
                id: `main.education.item-${i}`,
                type: 'container' as const,
                fieldPath: `educations[${i}]`,
                children: [
                    { id: `main.education.item-${i}.degree`, type: 'text' as const, content: edu.degree || '', style: { fontWeight: 'bold', fontSize: theme.fontSize.body } },
                    { id: `main.education.item-${i}.school`, type: 'text' as const, content: edu.school || '', style: { fontSize: theme.fontSize.body } },
                    { id: `main.education.item-${i}.year`, type: 'text' as const, content: edu.year || '', style: { fontSize: theme.fontSize.small } },
                ],
            }));

        children.push({
            id: 'main.education',
            type: 'section',
            children: [
                { id: 'main.education.title', type: 'text', content: 'Formation', style: { fontWeight: 'bold', textTransform: 'uppercase', fontSize: theme.fontSize.sectionTitle } },
                ...eduItems,
            ],
        });
    }

    return {
        id: 'main',
        type: 'container',
        children,
        style: {
            // Phase 5.4: Scaled padding from theme (kept minimal to prevent overflow)
            paddingTop: theme.spacing.sectionMargin,
            paddingBottom: theme.spacing.sectionMargin,
            paddingLeft: theme.spacing.itemMargin,
            paddingRight: theme.spacing.itemMargin,
            fontSize: theme.fontSize.body,
        },
    };
}

// ============================================================================
// PHASE 4.2: NEW CONTAINER NODE CREATORS
// ============================================================================

/**
 * Phase 5.3: Photo scale metrics map.
 * Provides consistent sizing based on design.photoScale (1|2|3).
 */
const PHOTO_SCALE_METRICS = {
    1: { headerHeight: 96, photoSize: 64, headerPadding: 12, nameFontSize: 18, titleFontSize: 11, bodyFontSize: 10 },
    2: { headerHeight: 112, photoSize: 80, headerPadding: 14, nameFontSize: 20, titleFontSize: 12, bodyFontSize: 10 },
    3: { headerHeight: 128, photoSize: 96, headerPadding: 16, nameFontSize: 22, titleFontSize: 13, bodyFontSize: 11 },
} as const;

function getPhotoScaleMetrics(design: DesignConfig) {
    const scale = design.photoScale ?? 2;
    return PHOTO_SCALE_METRICS[scale] ?? PHOTO_SCALE_METRICS[2];
}

/**
 * Phase 6: Normalize experience dates to a stable display string.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function normalizeExperienceDates(exp: any): string {
    if (exp.dates) return exp.dates;
    if (exp.dateRange?.displayString) return exp.dateRange.displayString;
    if (exp.startDate) {
        return exp.endDate ? `${exp.startDate} - ${exp.endDate}` : `${exp.startDate} - Present`;
    }
    return '';
}

/**
 * Phase 6: Build compact contact line from profile.
 */
function buildContactLine(profile: CVProfile): string {
    const parts: string[] = [];
    if (profile.personal?.contact?.email) parts.push(profile.personal.contact.email);
    if (profile.personal?.contact?.phone) parts.push(profile.personal.contact.phone);
    const address = profile.personal?.contact?.address as string | { city?: string } | undefined;
    if (address) {
        if (typeof address === 'string') parts.push(address);
        else if (address.city) parts.push(address.city);
    }
    return parts.join(' â€¢ ');
}

/**
 * Create header container node (for TOP_HEADER preset).
 * Phase 5.3: Uses photoScale metrics for consistent sizing.
 */
function createHeaderNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const accentColor = design.accentColor || '#2563EB';
    const metrics = getPhotoScaleMetrics(design);

    // Text block (name + title wrapped in column container for vertical stacking)
    const textBlockChildren: SceneNode[] = [];

    textBlockChildren.push({
        id: 'header.name',
        type: 'text',
        content: `${profile.personal?.firstName || ''} ${profile.personal?.lastName || ''}`.trim(),
        fieldPath: 'personal.fullName', // Sprint 6.1: Correct fieldPath for full name
        style: { fontSize: metrics.nameFontSize, fontWeight: 'bold', color: '#FFFFFF' },
    });

    if (profile.personal?.title) {
        textBlockChildren.push({
            id: 'header.title',
            type: 'text',
            content: profile.personal.title,
            fieldPath: 'personal.title',
            style: { fontSize: metrics.titleFontSize, color: '#FFFFFF' },
        });
    }

    // Phase 6: Contact line in header (email | phone | city)
    const contactLine = buildContactLine(profile);
    if (contactLine) {
        textBlockChildren.push({
            id: 'header.contact',
            type: 'text',
            content: contactLine,
            style: { fontSize: 9, color: '#E5E7EB' },
        });
    }

    // Phase 5.2: Wrap text in column container
    children.push({
        id: 'header.textBlock',
        type: 'container',
        children: textBlockChildren,
        style: {
            direction: 'column',
            gap: 2,
        },
    });

    // Photo on right (if enabled) - Phase 5.3: Size from metrics
    if (design.showPhoto) {
        const photoUrl = profile.personal?.photoUrl || 'PLACEHOLDER_PHOTO';
        children.push({
            id: 'header.photo',
            type: 'image',
            content: photoUrl,
            fieldPath: 'personal.photoUrl',
            style: { width: metrics.photoSize, height: metrics.photoSize },
        });
    }

    return {
        id: 'header',
        type: 'container',
        children,
        style: {
            backgroundColor: accentColor,
            paddingTop: metrics.headerPadding,
            paddingBottom: metrics.headerPadding,
            paddingLeft: 24,
            paddingRight: 24,
            // Phase 5.2: Flex layout for vertical centering
            direction: 'row',
            alignItems: 'center',
            justifyContent: 'spaceBetween',
        },
    };
}

/**
 * Create headerLeft container node (for SPLIT_HEADER preset).
 * Phase 5.1: Name/title only - photo moved to headerRight.
 */
function createHeaderLeftNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const accentColor = design.accentColor || '#2563EB';

    const metrics = getPhotoScaleMetrics(design);

    // Name (no photo here - moved to headerRight)
    children.push({
        id: 'headerLeft.name',
        type: 'text',
        content: `${profile.personal?.firstName || ''} ${profile.personal?.lastName || ''}`.trim(),
        fieldPath: 'personal.fullName', // Sprint 6.1: Correct fieldPath for full name
        style: { fontSize: metrics.nameFontSize, fontWeight: 'bold', color: '#FFFFFF' },
    });

    if (profile.personal?.title) {
        children.push({
            id: 'headerLeft.title',
            type: 'text',
            content: profile.personal.title,
            fieldPath: 'personal.title',
            style: { fontSize: metrics.titleFontSize, color: '#FFFFFF' },
        });
    }

    return {
        id: 'headerLeft',
        type: 'container',
        children,
        style: {
            backgroundColor: accentColor,
            paddingTop: metrics.headerPadding,
            paddingBottom: metrics.headerPadding,
            paddingLeft: 16,
            paddingRight: 12,
            // Phase 5.3: Vertical centering
            direction: 'column',
            justifyContent: 'center',
            gap: 2,
        },
    };
}

/**
 * Create headerRight container node (for SPLIT_HEADER preset).
 * Phase 6: Photo AND contact shown together (not either/or).
 */
function createHeaderRightNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];

    const metrics = getPhotoScaleMetrics(design);

    // Phase 6: Photo in RIGHT header (if enabled) - size from metrics
    if (design.showPhoto) {
        const photoUrl = profile.personal?.photoUrl || 'PLACEHOLDER_PHOTO';
        children.push({
            id: 'headerRight.photo',
            type: 'image',
            content: photoUrl,
            fieldPath: 'personal.photoUrl',
            style: { width: metrics.photoSize, height: metrics.photoSize },
        });
    }

    // Phase 6: Contact info ALWAYS shown (alongside photo, not instead of)
    const contactChildren: SceneNode[] = [];
    if (profile.personal?.contact?.email) {
        contactChildren.push({
            id: 'headerRight.email',
            type: 'text',
            content: profile.personal.contact.email,
            fieldPath: 'personal.contact.email',
            style: { fontSize: 9, color: '#374151' },
        });
    }
    if (profile.personal?.contact?.phone) {
        contactChildren.push({
            id: 'headerRight.phone',
            type: 'text',
            content: profile.personal.contact.phone,
            fieldPath: 'personal.contact.phone',
            style: { fontSize: 9, color: '#374151' },
        });
    }
    if (profile.personal?.contact?.address) {
        const address = profile.personal.contact.address as string | { city?: string };
        const addressText = typeof address === 'string' ? address : (address.city || '');
        if (addressText) {
            contactChildren.push({
                id: 'headerRight.address',
                type: 'text',
                content: addressText,
                fieldPath: 'personal.contact.address',
                style: { fontSize: 9, color: '#374151' },
            });
        }
    }

    if (contactChildren.length > 0) {
        children.push({
            id: 'headerRight.contactBlock',
            type: 'container',
            children: contactChildren,
            style: { direction: 'column', gap: 1 },
        });
    }

    // Ensure never empty - add placeholder content
    if (children.length === 0) {
        children.push({
            id: 'headerRight.placeholder',
            type: 'text',
            content: ' ', // Minimal placeholder
            style: { fontSize: 10, color: '#9CA3AF' },
        });
    }

    return {
        id: 'headerRight',
        type: 'container',
        children,
        style: {
            backgroundColor: '#F3F4F6',
            paddingTop: 10,
            paddingBottom: 10,
            paddingLeft: 12,
            paddingRight: 16,
            // Phase 6: Row layout for photo + contact side by side
            direction: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            gap: 10,
        },
    };
}

/**
 * Create leftRail container node (for LEFT_RAIL / DUAL_SIDEBAR presets).
 * Phase 5.4: Uses scaled theme for typography.
 */
function createLeftRailNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const accentColor = design.accentColor || '#2563EB';
    const theme = getScaledTheme(design.photoScale ?? 2);
    const structure = getStructure(design);

    // Skills icons/labels (compact) - Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'skills') && profile.skills && profile.skills.length > 0) {
        const skillItems = profile.skills.slice(0, structure.limits.skillsTopN).map((skill: any, i: number) => ({
            id: `leftRail.skills.item-${i}`,
            type: 'text' as const,
            content: typeof skill === 'string' ? skill : (skill.name || ''),
            style: { fontSize: theme.fontSize.small, color: '#FFFFFF', textAlign: 'center' as const },
        }));

        children.push({
            id: 'leftRail.skills',
            type: 'section',
            children: [
                { id: 'leftRail.skills.title', type: 'text', content: 'SKILLS', style: { fontSize: theme.fontSize.sectionTitle, fontWeight: 'bold', color: '#FFFFFF', textAlign: 'center', letterSpacing: 0.5 } },
                ...skillItems,
            ],
        });
    }

    return {
        id: 'leftRail',
        type: 'container',
        children,
        style: {
            backgroundColor: accentColor,
            paddingTop: theme.spacing.sectionMargin + 12,
            paddingBottom: theme.spacing.sectionMargin + 12,
            paddingLeft: theme.spacing.itemMargin,
            paddingRight: theme.spacing.itemMargin,
        },
    };
}

/**
 * Create rightRail container node (for DUAL_SIDEBAR preset).
 * Phase 5.4: Uses scaled theme for typography.
 */
function createRightRailNode(profile: CVProfile, design: DesignConfig): SceneNode {
    const children: SceneNode[] = [];
    const theme = getScaledTheme(design.photoScale ?? 2);
    const structure = getStructure(design);

    // Languages in right rail - Phase 7.1: Check visibility + apply limits
    if (isSectionVisible(structure, 'languages') && profile.languages && profile.languages.length > 0) {
        const langItems = profile.languages.slice(0, structure.limits.languagesTopN).map((lang, i) => ({
            id: `rightRail.languages.item-${i}`,
            type: 'text' as const,
            content: `${lang.name || lang} ${lang.level ? `(${lang.level})` : ''}`.trim(),
            style: { fontSize: theme.fontSize.small, color: '#374151' },
        }));

        children.push({
            id: 'rightRail.languages',
            type: 'section',
            children: [
                { id: 'rightRail.languages.title', type: 'text', content: 'Langues', style: { fontWeight: 'bold', fontSize: theme.fontSize.sectionTitle, textTransform: 'uppercase' } },
                ...langItems,
            ],
        });
    }

    // Contact in right rail - Phase 7.1: Check visibility
    if (isSectionVisible(structure, 'contact') && (profile.personal?.contact?.email || profile.personal?.contact?.phone)) {
        const contactItems: SceneNode[] = [];
        if (profile.personal.contact.email) {
            contactItems.push({
                id: 'rightRail.contact.email',
                type: 'text',
                content: profile.personal.contact.email,
                style: { fontSize: theme.fontSize.small, color: '#374151' },
            });
        }
        if (profile.personal.contact.phone) {
            contactItems.push({
                id: 'rightRail.contact.phone',
                type: 'text',
                content: profile.personal.contact.phone,
                style: { fontSize: theme.fontSize.small, color: '#374151' },
            });
        }

        children.push({
            id: 'rightRail.contact',
            type: 'section',
            children: [
                { id: 'rightRail.contact.title', type: 'text', content: 'Contact', style: { fontWeight: 'bold', fontSize: theme.fontSize.sectionTitle, textTransform: 'uppercase' } },
                ...contactItems,
            ],
        });
    }

    return {
        id: 'rightRail',
        type: 'container',
        children,
        style: {
            backgroundColor: '#F9FAFB',
            paddingTop: theme.spacing.sectionMargin + 12,
            paddingBottom: theme.spacing.sectionMargin + 12,
            paddingLeft: theme.spacing.itemMargin,
            paddingRight: theme.spacing.itemMargin,
        },
    };
}

export default buildScene;
</file>

<file path="scenegraph/index.ts">
/**
 * NEXAL2 - SceneGraph Module
 */

export { buildScene } from './buildScene';
</file>

<file path="test/fixtures.ts">
/**
 * NEXAL2 - Test Fixtures
 *
 * Mock profile and design for visual testing.
 * This data renders the same every time for comparison.
 *
 * NOTE: These fixtures use 'as' type assertions to allow
 * partial data that works with buildScene() without requiring
 * every field from the full domain types.
 */

import type { CVProfile } from '@/domain/cv/v2/types';
import type { DesignConfig } from '@/application/store/v2/cv-store-v2.types';

// Use Partial types for test flexibility
type TestProfile = Partial<CVProfile> & { personal?: Record<string, unknown> };
type TestDesign = Partial<DesignConfig>;

/**
 * Fixture profile with realistic data for testing.
 */
export const FIXTURE_PROFILE = {
    id: 'fixture-001',
    personal: {
        firstName: 'Marie',
        lastName: 'Dubois',
        title: 'DÃ©veloppeuse Full-Stack Senior',
        photoUrl: '',
        contact: {
            email: 'marie.dubois@example.com',
            phone: '+33 6 12 34 56 78',
            linkedin: 'linkedin.com/in/mariedubois',
        },
    },
    summary: 'DÃ©veloppeuse passionnÃ©e avec 8 ans d\'expÃ©rience en dÃ©veloppement web. SpÃ©cialisÃ©e en React, Node.js et architectures cloud. J\'aime crÃ©er des produits qui ont un impact positif sur les utilisateurs.',
    experiences: [
        {
            id: 'exp-1',
            role: 'Lead Developer',
            company: 'TechCorp Paris',
            dates: '2021 - PrÃ©sent',
            dateRange: { displayString: '2021 - PrÃ©sent' },
            location: 'Paris',
            tasks: [
                'Direction technique d\'une Ã©quipe de 5 dÃ©veloppeurs',
                'Migration de l\'architecture monolithique vers micro-services',
                'RÃ©duction du temps de chargement de 60%',
                'Mise en place CI/CD avec GitHub Actions',
            ],
        },
        {
            id: 'exp-2',
            role: 'Senior Frontend Developer',
            company: 'StartupLab',
            dates: '2018 - 2021',
            dateRange: { displayString: '2018 - 2021' },
            location: 'Lyon',
            tasks: [
                'DÃ©veloppement d\'une plateforme SaaS B2B',
                'IntÃ©gration de Stripe pour les paiements',
                'Optimisation SEO et performances',
            ],
        },
    ],
    educations: [
        {
            id: 'edu-1',
            degree: 'Master Informatique',
            school: 'UniversitÃ© Paris-Saclay',
            year: '2016',
        },
        {
            id: 'edu-2',
            degree: 'Licence Informatique',
            school: 'UniversitÃ© Claude Bernard Lyon 1',
            year: '2014',
        },
    ],
    skills: [
        'React',
        'TypeScript',
        'Node.js',
        'PostgreSQL',
        'AWS',
        'Docker',
        'GraphQL',
        'Python',
    ],
    languages: [
        { name: 'FranÃ§ais', level: 'Natif' },
        { name: 'Anglais', level: 'Courant (C1)' },
        { name: 'Espagnol', level: 'IntermÃ©diaire (B1)' },
    ],
    metadata: {
        templateId: 'modern',
    },
};

/**
 * Fixture design config for A4 format.
 */
export const FIXTURE_DESIGN_A4 = {
    paperFormat: 'A4' as const,
    showPhoto: true,
    targetCountry: 'FR',
    accentColor: '#4F46E5',
    sidebarPosition: 'left' as const,
    bulletStyle: 'disc',
    profileTheme: 'professional',
    photoShape: 'rounded',
    photoSize: 80,
};

/**
 * Fixture design config for US Letter format.
 */
export const FIXTURE_DESIGN_LETTER = {
    paperFormat: 'LETTER' as const,
    showPhoto: false,
    targetCountry: 'US',
    accentColor: '#2563EB',
    sidebarPosition: 'left' as const,
    bulletStyle: 'disc',
    profileTheme: 'professional',
    photoShape: 'rounded',
    photoSize: 80,
};
</file>

<file path="test/index.ts">
/**
 * NEXAL2 - Test Module
 */

export { Nexal2TestPage } from './Nexal2TestPage';
export { FIXTURE_PROFILE, FIXTURE_DESIGN_A4, FIXTURE_DESIGN_LETTER } from './fixtures';
</file>

<file path="test/Nexal2TestPage.tsx">
/**
 * NEXAL2 - Test Page Component
 *
 * Visual testing page for the NEXAL2 rendering pipeline.
 * Renders the fixture profile using buildScene + computeLayout + HTMLRenderer.
 *
 * Access via: /nexal2-test (when route is added)
 */

import React, { useMemo, useState, useCallback } from 'react';
import { buildScene } from '../scenegraph';
import { computeLayout } from '../layout';
import { HTMLRenderer } from '../renderers/html';
import { PDFRenderer } from '../renderers/pdf';
import { pdf } from '@react-pdf/renderer';
import { createDefaultConstraints, PAPER_DIMENSIONS } from '../';
import { FIXTURE_PROFILE, FIXTURE_DESIGN_A4, FIXTURE_DESIGN_LETTER } from './fixtures';
import type { LayoutConstraints, LayoutNode } from '../types';

export const Nexal2TestPage: React.FC = () => {
    const [format, setFormat] = useState<'A4' | 'LETTER'>('A4');
    const [showPhoto, setShowPhoto] = useState(true);
    const [debug, setDebug] = useState(true);
    const [scale, setScale] = useState(0.7);

    // Stress test controls
    const [skillCount, setSkillCount] = useState(8);
    const [experienceCount, setExperienceCount] = useState(2);
    const [seed, setSeed] = useState(1);

    // Generate stress-modified profile
    const stressProfile = useMemo(() => {
        // Generate extra skills
        const extraSkills = Array.from({ length: skillCount }, (_, i) =>
            i < FIXTURE_PROFILE.skills.length
                ? FIXTURE_PROFILE.skills[i]
                : `Skill ${i + 1}`
        );

        // Generate extra experiences
        const baseExp = FIXTURE_PROFILE.experiences[0];
        const extraExperiences = Array.from({ length: experienceCount }, (_, i) =>
            i < FIXTURE_PROFILE.experiences.length
                ? FIXTURE_PROFILE.experiences[i]
                : {
                    id: `exp-${i + 1}`,
                    role: `${['Senior', 'Lead', 'Junior'][i % 3]} Developer`,
                    company: `Company ${i + 1}`,
                    dates: `202${9 - i} - 202${9 - i + 1}`,
                    dateRange: { displayString: `202${9 - i} - 202${9 - i + 1}` },
                    location: 'Paris',
                    tasks: [
                        'Task description line 1',
                        'Task description line 2',
                    ],
                }
        );

        return {
            ...FIXTURE_PROFILE,
            skills: extraSkills,
            experiences: extraExperiences,
            // Use seed to force rebuild
            _seed: seed,
        };
    }, [skillCount, experienceCount, seed]);

    // Select design based on format
    const design = useMemo(() => {
        const base = format === 'A4' ? FIXTURE_DESIGN_A4 : FIXTURE_DESIGN_LETTER;
        return { ...base, showPhoto };
    }, [format, showPhoto]);

    // Build scene
    const scene = useMemo(() => {
        return buildScene(stressProfile, design);
    }, [stressProfile, design]);

    // Compute layout
    const constraints: LayoutConstraints = useMemo(() => {
        return createDefaultConstraints(format, 'left');
    }, [format]);

    const layout = useMemo(() => {
        return computeLayout(scene, constraints);
    }, [scene, constraints]);

    // Paper dimensions for display
    const paper = PAPER_DIMENSIONS[format];

    // Layout signature for parity proof (HTML = PDF)
    const layoutSignature = useMemo(() => {
        const flat: Array<[string, number, number, number, number, string]> = [];
        const walk = (n: LayoutNode) => {
            flat.push([
                n.nodeId,
                Math.round(n.frame.x), Math.round(n.frame.y),
                Math.round(n.frame.width), Math.round(n.frame.height),
                n.nodeType
            ]);
            n.children?.forEach(walk);
        };
        layout.pages.forEach(walk);
        // Create a short hash from the layout data
        const json = JSON.stringify(flat);
        let hash = 0;
        for (let i = 0; i < json.length; i++) {
            const char = json.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(16).toUpperCase().padStart(8, '0').slice(0, 8);
    }, [layout]);

    // PDF download handler
    const [isDownloading, setIsDownloading] = useState(false);
    const handleDownloadPDF = useCallback(async () => {
        setIsDownloading(true);
        try {
            const pdfDoc = <PDFRenderer layout={layout} title="NEXAL2-CV" layoutSignature={layoutSignature} />;
            const blob = await pdf(pdfDoc).toBlob();
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `CV-NEXAL2-${format}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('[NEXAL2] PDF download error:', error);
            alert('PDF generation failed. Check console for details.');
        } finally {
            setIsDownloading(false);
        }
    }, [layout, format, layoutSignature]);

    // PDF preview inline (compare mode)
    const [pdfPreviewUrl, setPdfPreviewUrl] = useState<string | null>(null);
    const [isRefreshing, setIsRefreshing] = useState(false);
    const refreshPdfPreview = useCallback(async () => {
        setIsRefreshing(true);
        try {
            const pdfDoc = <PDFRenderer layout={layout} title="NEXAL2-CV" layoutSignature={layoutSignature} />;
            const blob = await pdf(pdfDoc).toBlob();
            const url = URL.createObjectURL(blob);
            setPdfPreviewUrl(prev => {
                if (prev) URL.revokeObjectURL(prev);
                return url;
            });
        } catch (error) {
            console.error('[NEXAL2] PDF preview error:', error);
        } finally {
            setIsRefreshing(false);
        }
    }, [layout, layoutSignature]);

    return (
        <div style={{
            minHeight: '100vh',
            backgroundColor: '#1a1a2e',
            padding: 32,
            fontFamily: 'system-ui, sans-serif',
        }}>
            {/* Header */}
            <div style={{ marginBottom: 24 }}>
                <h1 style={{ color: '#fff', fontSize: 24, marginBottom: 8 }}>
                    ðŸ§ª NEXAL2 Test Page
                </h1>
                <p style={{ color: '#888', fontSize: 14 }}>
                    SceneGraph â†’ Layout â†’ HTML Renderer
                </p>
            </div>

            {/* Controls */}
            <div style={{
                display: 'flex',
                gap: 16,
                marginBottom: 24,
                flexWrap: 'wrap',
            }}>
                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8 }}>
                    Format:
                    <select
                        value={format}
                        onChange={(e) => setFormat(e.target.value as 'A4' | 'LETTER')}
                        style={{ padding: '4px 8px', borderRadius: 4 }}
                    >
                        <option value="A4">A4 (595Ã—842 pt)</option>
                        <option value="LETTER">Letter (612Ã—792 pt)</option>
                    </select>
                </label>

                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8 }}>
                    <input
                        type="checkbox"
                        checked={showPhoto}
                        onChange={(e) => setShowPhoto(e.target.checked)}
                    />
                    Show Photo
                </label>

                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8 }}>
                    <input
                        type="checkbox"
                        checked={debug}
                        onChange={(e) => setDebug(e.target.checked)}
                    />
                    Debug Borders
                </label>

                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8 }}>
                    Scale:
                    <input
                        type="range"
                        min="0.3"
                        max="1"
                        step="0.1"
                        value={scale}
                        onChange={(e) => setScale(parseFloat(e.target.value))}
                    />
                    {(scale * 100).toFixed(0)}%
                </label>
            </div>

            {/* Stress Test Controls */}
            <div style={{
                display: 'flex',
                gap: 16,
                marginBottom: 24,
                flexWrap: 'wrap',
                padding: 12,
                backgroundColor: 'rgba(255,100,100,0.1)',
                borderRadius: 8,
                border: '1px solid rgba(255,100,100,0.3)',
            }}>
                <span style={{ color: '#f77', fontWeight: 'bold', fontSize: 12 }}>ðŸ§ª STRESS TEST:</span>

                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8, fontSize: 12 }}>
                    Skills:
                    <input
                        type="range"
                        min="1"
                        max="20"
                        value={skillCount}
                        onChange={(e) => setSkillCount(parseInt(e.target.value))}
                        style={{ width: 60 }}
                    />
                    {skillCount}
                </label>

                <label style={{ color: '#fff', display: 'flex', alignItems: 'center', gap: 8, fontSize: 12 }}>
                    Experiences:
                    <input
                        type="range"
                        min="1"
                        max="8"
                        value={experienceCount}
                        onChange={(e) => setExperienceCount(parseInt(e.target.value))}
                        style={{ width: 60 }}
                    />
                    {experienceCount}
                </label>

                <button
                    onClick={() => setSeed(s => s + 1)}
                    style={{
                        padding: '4px 12px',
                        borderRadius: 4,
                        backgroundColor: '#f77',
                        color: '#000',
                        border: 'none',
                        cursor: 'pointer',
                        fontSize: 12,
                        fontWeight: 'bold',
                    }}
                >
                    ðŸ”„ Regenerate
                </button>

                <button
                    onClick={handleDownloadPDF}
                    disabled={isDownloading}
                    style={{
                        padding: '4px 12px',
                        borderRadius: 4,
                        backgroundColor: isDownloading ? '#666' : '#4F46E5',
                        color: '#fff',
                        border: 'none',
                        cursor: isDownloading ? 'wait' : 'pointer',
                        fontSize: 12,
                        fontWeight: 'bold',
                    }}
                >
                    {isDownloading ? 'â³ Generating...' : 'ðŸ“¥ Download PDF (NEXAL2)'}
                </button>

                <button
                    onClick={refreshPdfPreview}
                    disabled={isRefreshing}
                    style={{
                        padding: '4px 12px',
                        borderRadius: 4,
                        backgroundColor: isRefreshing ? '#666' : '#10B981',
                        color: '#fff',
                        border: 'none',
                        cursor: isRefreshing ? 'wait' : 'pointer',
                        fontSize: 12,
                        fontWeight: 'bold',
                    }}
                >
                    {isRefreshing ? 'â³ Loading...' : 'ðŸ”„ Refresh PDF Preview'}
                </button>
            </div>

            {/* Stats */}
            <div style={{
                display: 'flex',
                gap: 24,
                marginBottom: 24,
                color: '#888',
                fontSize: 12,
            }}>
                <span>ðŸ“„ Paper: {format} ({paper.width.toFixed(0)}Ã—{paper.height.toFixed(0)} pt)</span>
                <span>ðŸ“Š Nodes: {countNodes(scene.pages[0])}</span>
                <span>ðŸ“ Scale: {(scale * 100).toFixed(0)}%</span>
                <span style={{ color: '#4F46E5', fontFamily: 'monospace' }}>ðŸ”’ LayoutSig: {layoutSignature}</span>
            </div>

            {/* Visual Checklist */}
            <div style={{
                marginBottom: 24,
                padding: 16,
                backgroundColor: 'rgba(255,255,255,0.05)',
                borderRadius: 8,
                border: '1px solid rgba(255,255,255,0.1)',
            }}>
                <h3 style={{ color: '#fff', fontSize: 14, marginBottom: 12 }}>
                    âœ… Visual Checklist
                </h3>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: 8, color: '#aaa', fontSize: 12 }}>
                    <div>â˜ No element overlaps</div>
                    <div>â˜ Padding visible on all sides</div>
                    <div>â˜ Section titles aligned</div>
                    <div>â˜ Sidebar width correct (170pt)</div>
                    <div>â˜ Text does not overflow</div>
                    <div>â˜ Same output on refresh</div>
                </div>
            </div>

            {/* Compare Mode: HTML vs PDF */}
            <div style={{
                display: 'flex',
                gap: 24,
                justifyContent: 'center',
                backgroundColor: '#0f0f1a',
                padding: 32,
                borderRadius: 8,
                overflow: 'auto',
            }}>
                {/* HTML Preview */}
                <div>
                    <div style={{ color: '#888', fontSize: 12, marginBottom: 8, textAlign: 'center' }}>
                        HTML Renderer
                    </div>
                    <div style={{
                        boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                        borderRadius: 4,
                        overflow: 'hidden',
                    }}>
                        <HTMLRenderer
                            layout={layout}
                            scale={scale}
                            debug={debug}
                            layoutSignature={layoutSignature}
                        />
                    </div>
                </div>

                {/* PDF Preview */}
                <div>
                    <div style={{ color: '#888', fontSize: 12, marginBottom: 8, textAlign: 'center' }}>
                        PDF Preview {!pdfPreviewUrl && '(click Refresh)'}
                    </div>
                    <div style={{
                        boxShadow: '0 4px 20px rgba(0,0,0,0.5)',
                        borderRadius: 4,
                        overflow: 'hidden',
                        width: paper.width * scale * (96 / 72),
                        height: paper.height * scale * (96 / 72),
                        backgroundColor: '#fff',
                    }}>
                        {pdfPreviewUrl ? (
                            <iframe
                                src={pdfPreviewUrl}
                                style={{
                                    width: '100%',
                                    height: '100%',
                                    border: 'none',
                                }}
                                title="PDF Preview"
                            />
                        ) : (
                            <div style={{
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                height: '100%',
                                color: '#888',
                                fontSize: 14,
                            }}>
                                Click "ðŸ”„ Refresh PDF Preview" to load
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* Debug: Scene JSON */}
            <details style={{ marginTop: 24, color: '#888' }}>
                <summary style={{ cursor: 'pointer', marginBottom: 8 }}>
                    ðŸ” Scene JSON (debug)
                </summary>
                <pre style={{
                    fontSize: 10,
                    backgroundColor: '#0f0f1a',
                    padding: 16,
                    borderRadius: 8,
                    overflow: 'auto',
                    maxHeight: 400,
                }}>
                    {JSON.stringify(scene, null, 2)}
                </pre>
            </details>
        </div >
    );
};

/**
 * Count total nodes in scene recursively.
 */
function countNodes(node: { children?: unknown[] }): number {
    let count = 1;
    if (node.children) {
        for (const child of node.children) {
            count += countNodes(child as { children?: unknown[] });
        }
    }
    return count;
}

export default Nexal2TestPage;
</file>

<file path="types.ts">
/**
 * NEXAL2 - SceneGraph Architecture Types
 *
 * Single source of truth for layout geometry.
 * All types match the spec in docs/nexal-scenegraph-spec.md
 */

import type { CVProfile } from '@/domain/cv/v2/types';
import type { DesignConfig } from '@/application/store/v2/cv-store-v2.types';

// ============================================================================
// SCENE GRAPH TYPES
// ============================================================================

export type SceneNodeType =
    | 'document'
    | 'page'
    | 'container'
    | 'section'
    | 'text'
    | 'image'
    | 'list'
    | 'listItem'
    | 'spacer';

export interface SceneStyle {
    // Typography
    fontSize?: number;
    fontWeight?: 'normal' | 'bold';
    fontFamily?: 'sans' | 'serif' | 'mono';
    lineHeight?: number;
    textAlign?: 'left' | 'center' | 'right';
    textTransform?: 'none' | 'uppercase';
    letterSpacing?: number;

    // Colors
    color?: string;
    backgroundColor?: string;

    // Spacing (in pt)
    marginTop?: number;
    marginBottom?: number;
    marginLeft?: number;
    marginRight?: number;
    paddingTop?: number;
    paddingBottom?: number;
    paddingLeft?: number;
    paddingRight?: number;
    gap?: number;

    // Borders
    borderWidth?: number;
    borderColor?: string;
    borderStyle?: 'solid' | 'dashed' | 'dotted' | 'none';
    borderRadius?: number;

    // Layout hints
    direction?: 'row' | 'column';
    /** Phase 5.2: Cross-axis alignment (flex alignItems) */
    alignItems?: 'start' | 'center' | 'end';
    /** Phase 5.2: Main-axis distribution (flex justifyContent) */
    justifyContent?: 'start' | 'center' | 'end' | 'spaceBetween';
    width?: number | 'auto';
    height?: number | 'auto';
    minHeight?: number;
    maxWidth?: number;
}

export interface SceneNode {
    id: string;
    type: SceneNodeType;
    children?: SceneNode[];
    content?: string;
    fieldPath?: string;
    style?: SceneStyle;
}

export interface SceneDocument {
    version: '1.0';
    paperFormat: 'A4' | 'LETTER';
    pageCount: number;
    pages: SceneNode[];
    metadata: {
        generatedAt: string;
        profileId: string;
        designHash: string;
    };
}

// ============================================================================
// LAYOUT TYPES
// ============================================================================

export interface LayoutFrame {
    x: number;
    y: number;
    width: number;
    height: number;
}

export interface ComputedStyle {
    fontSize: number;
    lineHeight: number;
    color: string;
    backgroundColor?: string;
    fontWeight: 'normal' | 'bold';
    fontFamily: string;
    textAlign: 'left' | 'center' | 'right';
    textTransform: 'none' | 'uppercase';
    letterSpacing?: number;
}

export interface LayoutNode {
    nodeId: string;
    nodeType: SceneNodeType; // Node type for renderer branching
    frame: LayoutFrame;
    children?: LayoutNode[];
    computedStyle: ComputedStyle;
    content?: string;
    fieldPath?: string;
}

export interface LayoutConstraints {
    paperFormat: 'A4' | 'LETTER';
    margins: { top: number; right: number; bottom: number; left: number };
    sidebarWidth: number;
    sidebarPosition: 'left' | 'right';
    sidebarGap: number;
}

export interface LayoutTree {
    pages: LayoutNode[];
    bounds: {
        width: number;
        height: number;
    };
    constraints: LayoutConstraints;
    /** Phase 4.9: Pagination metadata */
    paginationMeta?: PaginationMeta;
}

/** Phase 4.9: Pagination metadata attached to LayoutTree */
export interface PaginationMeta {
    /** Number of pages */
    pageCount: number;
    /** Whether pagination occurred */
    didPaginate: boolean;
    /** Y positions where splits occurred */
    splitPoints: number[];
    /** Structured warnings from pagination */
    warnings: PaginationWarning[];
    /** Per-page parity signatures (hash of node frames/types) */
    pageSignatures: string[];
}

/** Phase 4.9: Structured pagination warning */
export interface PaginationWarning {
    code: 'OVERSIZED_BLOCK' | 'ORPHAN_TITLE' | 'FORCED_BREAK';
    nodeId: string;
    nodeType: string;
    message: string;
    data?: Record<string, unknown>;
}

// ============================================================================
// TEXT MEASUREMENT
// ============================================================================

export interface TextMeasurement {
    width: number;
    height: number;
    lineCount: number;
}

// ============================================================================
// PAPER DIMENSIONS (in points)
// ============================================================================

export const PAPER_DIMENSIONS = {
    A4: { width: 595.28, height: 841.89 },
    LETTER: { width: 612, height: 792 },
} as const;

// ============================================================================
// DEFAULT THEME VALUES
// ============================================================================

export const DEFAULT_NEXAL_THEME = {
    margins: { top: 40, right: 40, bottom: 40, left: 40 },
    sidebarWidth: 170,
    sidebarGap: 20,
    fontSize: {
        name: 18,
        title: 12,
        sectionTitle: 11,
        body: 10,
        small: 9,
    },
    lineHeight: 1.4,
    spacing: {
        sectionMargin: 16,
        itemMargin: 8,
        subsectionMargin: 6,
    },
} as const;

/**
 * Phase 5.3: Get scaled theme based on photoScale (1|2|3).
 * Scales typography and spacing globally.
 */
export function getScaledTheme(photoScale: 1 | 2 | 3 = 2) {
    // Scale factors: 1 = 1.0, 2 = 1.12, 3 = 1.25
    const factors = { 1: 1.0, 2: 1.12, 3: 1.25 } as const;
    const factor = factors[photoScale] ?? 1.12;

    const base = DEFAULT_NEXAL_THEME;

    return {
        margins: base.margins,
        sidebarWidth: base.sidebarWidth,
        sidebarGap: base.sidebarGap,
        fontSize: {
            name: Math.round(base.fontSize.name * factor),
            title: Math.round(base.fontSize.title * factor),
            sectionTitle: Math.round(base.fontSize.sectionTitle * factor),
            body: Math.round(base.fontSize.body * factor),
            small: Math.round(base.fontSize.small * factor),
        },
        lineHeight: base.lineHeight,
        spacing: {
            sectionMargin: Math.round(base.spacing.sectionMargin * factor),
            itemMargin: Math.round(base.spacing.itemMargin * factor),
            subsectionMargin: Math.round(base.spacing.subsectionMargin * factor),
        },
    };
}

// ============================================================================
// RE-EXPORT DOMAIN TYPES FOR CONVENIENCE
// ============================================================================

export type { CVProfile, DesignConfig };
</file>

</files>
